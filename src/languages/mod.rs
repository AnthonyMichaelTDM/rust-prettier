//! this module contains implementations of trait below for each of the supported languages
//!
//!

use std::borrow::Cow;

use crate::{document::Doc, PrettyPrinter};

pub mod javascript;

// TODO AstPath trait or something

/// this super trait ensures is used to bundle all the traits required to support a language
///
/// this is important to ensure that the associated types remain consistent for a given language
///
///
/// # The Printing Process
///
/// Prettier uses an intermediate representation, called a `Doc`, which Prettier then turns into a string (based on options like `print_width`).
/// A printer's job is to take an `AST` generated by functions defined by the `ParseToAST` trait and return a `Doc`.
/// A `Doc` is constructed using builder commands:
///
/// ```no_run
/// use rust_prettier::document;
///
/// use document::builders::{ join, line, if_break, group };
/// ```
///
/// The printing process consists of the following steps:
///
/// 1. AST preprocessing (optional). See `PrintToAst::preprocess`.
/// 2. Comment attachment (optional). See [Handling comments in a printer](https://prettier.io/docs/en/plugins#handling-comments-in-a-printer).
/// 3. Processing embedded languages (optional). Not Supported yet, but the original Docs has this to say: The embed method, if defined, is called for each node, depth-first. While, for performance reasons, the recursion itself is synchronous, embed may return asynchronous functions that can call other parsers and printers to compose docs for embedded syntaxes like CSS-in-JS. These returned functions are queued up and sequentially executed before the next step.
/// 4. Recursive printing. A `Doc` is recursively constructed from the `AST`. Starting from the root node:
///    - If, from the step 3, there is an embedded language doc associated with the current node, this doc is used.
///    - Otherwise, the `print(path, options, print_callback): Doc` method is called. It composes a `Doc` for the current node, often by printing child nodes using the `print_callback`.
pub trait Language<Ast, AstNode, AstPath, Error, Options: From<PrettyPrinter> + Default>:
    ParseToAST<Ast, AstNode, Error, Options> + PrintToDoc<Ast, AstNode, AstPath, Error, Options>
{
}

/// this trait defines the behavior of the "Text -> AST" part of the formatting process
///
/// functions are `&self` for flexibility, what if a parser has an expensive startup or needs some kind of persistent state (ex: values of a config file that overrides `Options`)
pub trait ParseToAST<Ast, AstNode, Error, Options: From<PrettyPrinter>> {
    /// Parse input text into an AST
    fn parse(&self, text: Cow<str>, options: Options) -> Result<Ast, Error>;

    /// The location extraction functions (`loc_start`` and `loc_end`) return the starting and ending locations of a given AST node:
    fn loc_start(&self, node: AstNode) -> usize;

    /// The location extraction functions (`loc_start`` and `loc_end`) return the starting and ending locations of a given AST node:
    fn loc_end(&self, node: AstNode) -> usize;

    /// Optional: The pragma detection function (has_pragma) should return if the text contains the pragma comment.
    ///
    /// # Returns
    /// - `None`: this parser does not support pragma's
    /// - `Some(true)`: pragma's are supported, and one was found in `text`
    /// - `Some(false)`: pragma's are supported, but none were found in `text`
    fn has_pragma(&self, _text: &str) -> Option<bool> {
        None
    }

    /// Optional: The preprocess function can process the input text before passing into parse function.
    ///
    /// # Returns:
    /// - `None`: there is no preprocessing defined for this parser.
    /// - `Some(Cow<str>)`: the string was processed, wrapped in a Cow smart pointer so that we only clone if we needed to
    ///     - if there is an error during pre-processing, just return hte unmodified input string.
    fn preprocess(&self, _text: Cow<str>, _options: Options) -> Option<Cow<str>> {
        None
    }
}

/// this trait defines the behavior of the "AST -> Doc" part of the formatting process
pub trait PrintToDoc<Ast, AstNode, AstPath, Error, Options: From<PrettyPrinter>>:
    HandleComments<Ast, AstNode, AstPath, Error, Options>
{
    /// # Arguments
    /// - path: An object, which can be used to access nodes in the AST. It’s a stack-like data structure that maintains the current state of the recursion. It is called “path” because it represents the path to the current node from the root of the AST. The current node is returned by path.get_value().
    /// - options: A persistent object, which contains global options and which a plugin may mutate to store contextual data.
    /// - print: A callback for printing sub-nodes. This function contains the core printing logic that consists of steps whose implementation is provided by plugins. In particular, it calls the printer’s print function and passes itself to it. Thus, the two print functions – the one from the core and the one from the plugin – call each other while descending down the AST recursively.
    fn print<State>(
        // Path to the AST node to print
        path: AstPath,
        options: Options,
        // Recursively print a child node
        print: impl Fn(Selector<AstPath>, Options, &mut State) -> Doc,
        // with this state (a cache for instance)
        state: &mut State,
    ) -> Doc;

    // TODO: Embed, see https://prettier.io/docs/en/plugins#optional-embed
    // it's out of scope for this initial project, but we'll want to do it eventually

    /// how a pragma comment is inserted in the resulting code when the --insert-pragma option is used
    ///
    fn insert_pragma(&self, text: &str) -> String;
}

/// Comments are often not part of a language's AST and present a challenge for pretty printers.
/// A Prettier plugin can either print comments itself in its print function or rely on Prettier's comment algorithm.
///
/// By default, if the AST has a top-level comments property,
/// Prettier assumes that comments stores an array of comment nodes.
/// Prettier will then use the provided parsers[<plugin>].locStart/locEnd functions to search for the AST node that each comment "belongs" to.
/// Comments are then attached to these nodes mutating the AST in the process, and the comments property is deleted from the AST root.
/// The *Comment functions are used to adjust Prettier's algorithm.
/// Once the comments are attached to the AST, Prettier will automatically call the printComment(path, options): Doc
/// function and insert the returned doc into the (hopefully) correct place.
pub trait HandleComments<Ast, AstNode, AstPath, Error, Options> {
    // TODO: comment handling https://prettier.io/docs/en/plugins#handling-comments-in-a-printer
}

/// Selector Enum: enum that represents the different types of selectors a printer's print_callback might use
///
/// TODO: come back to this
#[allow(dead_code)]
pub enum Selector<AstPath> {
    String(&'static str),
    Number(usize),
    Array(Vec<Selector<AstPath>>),
    AstPath(AstPath),
}
