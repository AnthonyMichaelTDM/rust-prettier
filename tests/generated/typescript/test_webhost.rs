#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[allow(dead_code)]
static INFINITY: usize = usize::MAX;
#[test]
fn test_webtsc_ts_format_1_1e35a31a() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parsers(vec!["typescript"])
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/// <reference path='..\\\\..\\\\src\\\\compiler\\\\tsc.ts'/>\n\nnamespace TypeScript.WebTsc {\n\n    declare var RealActiveXObject: { new (s: string): any };\n\n    function getWScriptSystem() {\n        const fso = new RealActiveXObject(\"Scripting.FileSystemObject\");\n\n        const fileStream = new ActiveXObject(\"ADODB.Stream\");\n        fileStream.Type = 2 /*text*/;\n\n        const args: string[] = [];\n        for (let i = 0; i < WScript.Arguments.length; i++) {\n            args[i] = WScript.Arguments.Item(i);\n        }\n        return {\n            args: args,\n            newLine: \"\\\\r\\\\n\",\n            write(s: string): void {\n                WScript.StdOut.Write(s);\n            },\n            writeErr(s: string): void {\n                WScript.StdErr.Write(s);\n            },\n            readFile(fileName: string, encoding?: string): string {\n                if (!fso.FileExists(fileName)) {\n                    return undefined;\n                }\n                fileStream.Open();\n                try {\n                    if (encoding) {\n                        fileStream.Charset = encoding;\n                        fileStream.LoadFromFile(fileName);\n                    }\n                    else {\n                        // Load file and read the first two bytes into a string with no interpretation\n                        fileStream.Charset = \"x-ansi\";\n                        fileStream.LoadFromFile(fileName);\n                        const bom = fileStream.ReadText(2) || \"\";\n                        // Position must be at 0 before encoding can be changed\n                        fileStream.Position = 0;\n                        // [0xFF,0xFE] and [0xFE,0xFF] mean utf-16 (little or big endian), otherwise default to utf-8\n                        fileStream.Charset = bom.length >= 2 && (bom.charCodeAt(0) === 0xFF && bom.charCodeAt(1) === 0xFE || bom.charCodeAt(0) === 0xFE && bom.charCodeAt(1) === 0xFF) ? \"unicode\" : \"utf-8\";\n                    }\n                    // ReadText method always strips byte order mark from resulting string\n                    return fileStream.ReadText();\n                }\n                catch (e) {\n                    throw e;\n                }\n                finally {\n                    fileStream.Close();\n                }\n            },\n            writeFile(fileName: string, data: string): boolean {\n                const f = fso.CreateTextFile(fileName, true);\n                f.Write(data);\n                f.Close();\n                return true;\n            },\n            resolvePath(path: string): string {\n                return fso.GetAbsolutePathName(path);\n            },\n            fileExists(path: string): boolean {\n                return fso.FileExists(path);\n            },\n            directoryExists(path: string) {\n                return fso.FolderExists(path);\n            },\n            createDirectory(directoryName: string) {\n                if (!this.directoryExists(directoryName)) {\n                    fso.CreateFolder(directoryName);\n                }\n            },\n            getExecutingFilePath() {\n                return WScript.ScriptFullName;\n            },\n            getCurrentDirectory() {\n                return \"\";\n            },\n            getMemoryUsage() {\n                return 0;\n            },\n            exit(exitCode?: number): void {\n                WScript.Quit(exitCode);\n            },\n            useCaseSensitiveFileNames: false\n        };\n    }\n\n    export function prepareCompiler(currentDir: string, stdOut: ITextWriter, stdErr: ITextWriter) {\n        const shell = new RealActiveXObject(\"WScript.Shell\");\n        shell.CurrentDirectory = currentDir;\n        WScript.ScriptFullName = currentDir + \"\\\\\\\\tc.js\";\n        WScript.StdOut = stdOut;\n        WScript.StdErr = stdErr;\n        sys = getWScriptSystem();\n\n        return (commandLine: string) => {\n            ts.executeCommandLine(commandLine.split(\" \"));\n        };\n    }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/// <reference path='..\\\\..\\\\src\\\\compiler\\\\tsc.ts'/>\n\nnamespace TypeScript.WebTsc {\n  declare var RealActiveXObject: { new (s: string): any };\n\n  function getWScriptSystem() {\n    const fso = new RealActiveXObject(\"Scripting.FileSystemObject\");\n\n    const fileStream = new ActiveXObject(\"ADODB.Stream\");\n    fileStream.Type = 2 /*text*/;\n\n    const args: string[] = [];\n    for (let i = 0; i < WScript.Arguments.length; i++) {\n      args[i] = WScript.Arguments.Item(i);\n    }\n    return {\n      args: args,\n      newLine: \"\\\\r\\\\n\",\n      write(s: string): void {\n        WScript.StdOut.Write(s);\n      },\n      writeErr(s: string): void {\n        WScript.StdErr.Write(s);\n      },\n      readFile(fileName: string, encoding?: string): string {\n        if (!fso.FileExists(fileName)) {\n          return undefined;\n        }\n        fileStream.Open();\n        try {\n          if (encoding) {\n            fileStream.Charset = encoding;\n            fileStream.LoadFromFile(fileName);\n          } else {\n            // Load file and read the first two bytes into a string with no interpretation\n            fileStream.Charset = \"x-ansi\";\n            fileStream.LoadFromFile(fileName);\n            const bom = fileStream.ReadText(2) || \"\";\n            // Position must be at 0 before encoding can be changed\n            fileStream.Position = 0;\n            // [0xFF,0xFE] and [0xFE,0xFF] mean utf-16 (little or big endian), otherwise default to utf-8\n            fileStream.Charset =\n              bom.length >= 2 &&\n              ((bom.charCodeAt(0) === 0xff && bom.charCodeAt(1) === 0xfe) ||\n                (bom.charCodeAt(0) === 0xfe && bom.charCodeAt(1) === 0xff))\n                ? \"unicode\"\n                : \"utf-8\";\n          }\n          // ReadText method always strips byte order mark from resulting string\n          return fileStream.ReadText();\n        } catch (e) {\n          throw e;\n        } finally {\n          fileStream.Close();\n        }\n      },\n      writeFile(fileName: string, data: string): boolean {\n        const f = fso.CreateTextFile(fileName, true);\n        f.Write(data);\n        f.Close();\n        return true;\n      },\n      resolvePath(path: string): string {\n        return fso.GetAbsolutePathName(path);\n      },\n      fileExists(path: string): boolean {\n        return fso.FileExists(path);\n      },\n      directoryExists(path: string) {\n        return fso.FolderExists(path);\n      },\n      createDirectory(directoryName: string) {\n        if (!this.directoryExists(directoryName)) {\n          fso.CreateFolder(directoryName);\n        }\n      },\n      getExecutingFilePath() {\n        return WScript.ScriptFullName;\n      },\n      getCurrentDirectory() {\n        return \"\";\n      },\n      getMemoryUsage() {\n        return 0;\n      },\n      exit(exitCode?: number): void {\n        WScript.Quit(exitCode);\n      },\n      useCaseSensitiveFileNames: false,\n    };\n  }\n\n  export function prepareCompiler(\n    currentDir: string,\n    stdOut: ITextWriter,\n    stdErr: ITextWriter,\n  ) {\n    const shell = new RealActiveXObject(\"WScript.Shell\");\n    shell.CurrentDirectory = currentDir;\n    WScript.ScriptFullName = currentDir + \"\\\\\\\\tc.js\";\n    WScript.StdOut = stdOut;\n    WScript.StdErr = stdErr;\n    sys = getWScriptSystem();\n\n    return (commandLine: string) => {\n      ts.executeCommandLine(commandLine.split(\" \"));\n    };\n  }\n}");
}
