#[allow(unused_imports)]
use anyhow::Result;
#[allow(unused_imports)]
use pretty_assertions::assert_eq;
#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[allow(dead_code)]
static INFINITY: usize = usize::MAX;
#[test]
fn test_nested_js_format_1_b1ee3ab9() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("someObject.someFunction().then(function() {\n  return someObject.someFunction().then(function() {\n    return someObject.someFunction().then(function() {\n      return someObject.someFunction().then(function() {\n        return someObject.someFunction().then(function() {\n          return someObject.someFunction().then(function() {\n            return someObject.someFunction().then(function() {\n              return someObject.someFunction().then(function() {\n                return someObject.someFunction().then(function() {\n                  return someObject.someFunction().then(function() {\n                    return someObject.someFunction().then(function() {\n                      return someObject.someFunction().then(function() {\n                        return someObject.someFunction().then(function() {\n                          return someObject.someFunction().then(function() {\n                            anotherFunction();\n                          });\n                        });\n                      });\n                    });\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n});") ? ;
    assert_eq ! (formatted , "someObject.someFunction().then(function () {\n  return someObject.someFunction().then(function () {\n    return someObject.someFunction().then(function () {\n      return someObject.someFunction().then(function () {\n        return someObject.someFunction().then(function () {\n          return someObject.someFunction().then(function () {\n            return someObject.someFunction().then(function () {\n              return someObject.someFunction().then(function () {\n                return someObject.someFunction().then(function () {\n                  return someObject.someFunction().then(function () {\n                    return someObject.someFunction().then(function () {\n                      return someObject.someFunction().then(function () {\n                        return someObject.someFunction().then(function () {\n                          return someObject.someFunction().then(function () {\n                            anotherFunction();\n                          });\n                        });\n                      });\n                    });\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n});");
    Ok(())
}
#[test]
fn test_nested_real_js_format_1_e76182d5() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("tap.test(\"RecordImport.advance\", (t) => {\n    const checkStates = (batches, states) => {\n        t.equal(batches.length, states.length);\n        for (const batch of batches) {\n            t.equal(batch.state, states.shift());\n            t.ok(batch.getCurState().name(i18n));\n        }\n    };\n\n    const batch = init.getRecordBatch();\n    const dataFile = path.resolve(process.cwd(), \"testData\", \"default.json\");\n\n    const getBatches = (callback) => {\n        RecordImport.find({}, \"\", {}, (err, batches) => {\n            callback(null, batches.filter((batch) => (batch.state !== \"error\" &&\n                batch.state !== \"completed\")));\n        });\n    };\n\n    mockFS((callback) => {\n        batch.setResults([fs.createReadStream(dataFile)], (err) => {\n            t.error(err, \"Error should be empty.\");\n            t.equal(batch.results.length, 6, \"Check number of results\");\n            for (const result of batch.results) {\n                t.equal(result.result, \"unknown\");\n                t.ok(result.data);\n                t.equal(result.data.lang, \"en\");\n            }\n\n            getBatches((err, batches) => {\n                checkStates(batches, [\"started\"]);\n\n                RecordImport.advance((err) => {\n                    t.error(err, \"Error should be empty.\");\n\n                    getBatches((err, batches) => {\n                        checkStates(batches, [\"process.completed\"]);\n\n                        // Need to manually move to the next step\n                        batch.importRecords((err) => {\n                            t.error(err, \"Error should be empty.\");\n\n                            getBatches((err, batches) => {\n                                checkStates(batches, [\"import.completed\"]);\n\n                                RecordImport.advance((err) => {\n                                    t.error(err, \"Error should be empty.\");\n\n                                    getBatches((err, batches) => {\n                                        checkStates(batches,\n                                            [\"similarity.sync.completed\"]);\n\n                                        RecordImport.advance((err) => {\n                                            t.error(err,\n                                                \"Error should be empty.\");\n\n                                            t.ok(batch.getCurState()\n                                                .name(i18n));\n\n                                            getBatches((err, batches) => {\n                                                checkStates(batches, []);\n                                                t.end();\n                                                callback();\n                                            });\n                                        });\n\n                                        t.ok(batch.getCurState().name(i18n));\n                                    });\n                                });\n\n                                t.ok(batch.getCurState().name(i18n));\n                            });\n                        });\n\n                        t.ok(batch.getCurState().name(i18n));\n                    });\n                });\n\n                t.ok(batch.getCurState().name(i18n));\n            });\n        });\n    });\n});") ? ;
    assert_eq ! (formatted , "tap.test(\"RecordImport.advance\", (t) => {\n  const checkStates = (batches, states) => {\n    t.equal(batches.length, states.length);\n    for (const batch of batches) {\n      t.equal(batch.state, states.shift());\n      t.ok(batch.getCurState().name(i18n));\n    }\n  };\n\n  const batch = init.getRecordBatch();\n  const dataFile = path.resolve(process.cwd(), \"testData\", \"default.json\");\n\n  const getBatches = (callback) => {\n    RecordImport.find({}, \"\", {}, (err, batches) => {\n      callback(\n        null,\n        batches.filter(\n          (batch) => batch.state !== \"error\" && batch.state !== \"completed\",\n        ),\n      );\n    });\n  };\n\n  mockFS((callback) => {\n    batch.setResults([fs.createReadStream(dataFile)], (err) => {\n      t.error(err, \"Error should be empty.\");\n      t.equal(batch.results.length, 6, \"Check number of results\");\n      for (const result of batch.results) {\n        t.equal(result.result, \"unknown\");\n        t.ok(result.data);\n        t.equal(result.data.lang, \"en\");\n      }\n\n      getBatches((err, batches) => {\n        checkStates(batches, [\"started\"]);\n\n        RecordImport.advance((err) => {\n          t.error(err, \"Error should be empty.\");\n\n          getBatches((err, batches) => {\n            checkStates(batches, [\"process.completed\"]);\n\n            // Need to manually move to the next step\n            batch.importRecords((err) => {\n              t.error(err, \"Error should be empty.\");\n\n              getBatches((err, batches) => {\n                checkStates(batches, [\"import.completed\"]);\n\n                RecordImport.advance((err) => {\n                  t.error(err, \"Error should be empty.\");\n\n                  getBatches((err, batches) => {\n                    checkStates(batches, [\"similarity.sync.completed\"]);\n\n                    RecordImport.advance((err) => {\n                      t.error(err, \"Error should be empty.\");\n\n                      t.ok(batch.getCurState().name(i18n));\n\n                      getBatches((err, batches) => {\n                        checkStates(batches, []);\n                        t.end();\n                        callback();\n                      });\n                    });\n\n                    t.ok(batch.getCurState().name(i18n));\n                  });\n                });\n\n                t.ok(batch.getCurState().name(i18n));\n              });\n            });\n\n            t.ok(batch.getCurState().name(i18n));\n          });\n        });\n\n        t.ok(batch.getCurState().name(i18n));\n      });\n    });\n  });\n});");
    Ok(())
}
