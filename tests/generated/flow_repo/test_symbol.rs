#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[test]
fn test_symbol_js_format_1_f4323bb9() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("declare var s: symbol;\n\n// Creation\n{\n  const x: symbol = Symbol(); // OK\n  const y: symbol = Symbol('bar'); // OK\n\n  Symbol('foo', 'bar'); // Error: unused argument\n}\n\n// Properties and methods\n{\n  const x: string = s.toString(); // OK\n  const y: ?symbol = s.valueOf(); // OK\n  const z: string | void = s.description; // OK\n}\n\n// Refinement\n{\n  const x: symbol | boolean = true;\n  if (typeof x === \"symbol\") {\n    (x: symbol); // OK\n    (x: boolean); // Error\n  } else {\n    (x: boolean); // OK\n    (x: symbol); // Error\n  }\n}\n\n// Well-known symbols\n{\n  (Symbol.hasInstance: symbol); // OK\n  (Symbol.isConcatSpreadable: symbol); // OK\n  (Symbol.match: symbol); // OK\n  (Symbol.matchAll: symbol); // OK\n  (Symbol.replace: symbol); // OK\n  (Symbol.search: symbol); // OK\n  (Symbol.species: symbol); // OK\n  (Symbol.split: symbol); // OK\n  (Symbol.toPrimitive: symbol); // OK\n  (Symbol.toStringTag: symbol); // OK\n  (Symbol.unscopables: symbol); // OK\n\n  const x: $SymbolMatch = Symbol.match; // OK\n  const y: $SymbolMatch = Symbol.toPrimitive; // Error\n}\n\n// Non-strict equality\n{\n  // Comparison with symbol is allowed\n  const s: symbol = Symbol();\n  const y: symbol = Symbol();\n  s == y; // OK\n  y == s; // OK\n  s != y; // OK\n  y != s; // OK\n}\n{\n  const s: symbol = Symbol();\n  // Cannot compare against non-symbols\n  const x: [] = [];\n  x == s; // Error\n  s == x; // Error\n  x != s; // Error\n  s != x; // Error\n}\n{\n  const s: symbol = Symbol();\n  // Other than null/void which we always allow\n  s == null; // OK\n  null == s; // OK\n  s == undefined; // OK\n  undefined == s; // OK\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "declare var s: symbol;\n\n// Creation\n{\n  const x: symbol = Symbol(); // OK\n  const y: symbol = Symbol(\"bar\"); // OK\n\n  Symbol(\"foo\", \"bar\"); // Error: unused argument\n}\n\n// Properties and methods\n{\n  const x: string = s.toString(); // OK\n  const y: ?symbol = s.valueOf(); // OK\n  const z: string | void = s.description; // OK\n}\n\n// Refinement\n{\n  const x: symbol | boolean = true;\n  if (typeof x === \"symbol\") {\n    (x: symbol); // OK\n    (x: boolean); // Error\n  } else {\n    (x: boolean); // OK\n    (x: symbol); // Error\n  }\n}\n\n// Well-known symbols\n{\n  (Symbol.hasInstance: symbol); // OK\n  (Symbol.isConcatSpreadable: symbol); // OK\n  (Symbol.match: symbol); // OK\n  (Symbol.matchAll: symbol); // OK\n  (Symbol.replace: symbol); // OK\n  (Symbol.search: symbol); // OK\n  (Symbol.species: symbol); // OK\n  (Symbol.split: symbol); // OK\n  (Symbol.toPrimitive: symbol); // OK\n  (Symbol.toStringTag: symbol); // OK\n  (Symbol.unscopables: symbol); // OK\n\n  const x: $SymbolMatch = Symbol.match; // OK\n  const y: $SymbolMatch = Symbol.toPrimitive; // Error\n}\n\n// Non-strict equality\n{\n  // Comparison with symbol is allowed\n  const s: symbol = Symbol();\n  const y: symbol = Symbol();\n  s == y; // OK\n  y == s; // OK\n  s != y; // OK\n  y != s; // OK\n}\n{\n  const s: symbol = Symbol();\n  // Cannot compare against non-symbols\n  const x: [] = [];\n  x == s; // Error\n  s == x; // Error\n  x != s; // Error\n  s != x; // Error\n}\n{\n  const s: symbol = Symbol();\n  // Other than null/void which we always allow\n  s == null; // OK\n  null == s; // OK\n  s == undefined; // OK\n  undefined == s; // OK\n}");
}
