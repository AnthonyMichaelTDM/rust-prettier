#[allow(unused_imports)]
use anyhow::Result;
#[allow(unused_imports)]
use pretty_assertions::assert_eq;
#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[allow(dead_code)]
static INFINITY: usize = usize::MAX;
#[test]
fn test_base_class_js_format_1_67d35efb() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\nclass Base {\n  unannotatedField;\n  annotatedField: number;\n  initializedField = 42;\n  initializedFieldWithThis = this.initializedField;\n  annotatedInitializedFieldValid: ?number = 42;\n  annotatedInitializedFieldInvalid: number = 'asdf'; // Error: string ~> number\n\n  static unannotatedField;\n  static annotatedField: number;\n  static initializedField = 'asdf';\n  static initializedFieldWithThis = this.initializedField;\n  static annotatedInitializedFieldValid: ?number = 42;\n  static annotatedInitializedFieldInvalid: number = 'asdf'; // Error: string ~> number\n}\n\nvar o = new Base();\n\n/**\n * Unannotated fields are open.\n */\n(o.unannotatedField: string);\n(o.unannotatedField: number);\n(Base.unannotatedField: string);\n(Base.unannotatedField: number);\n\n/**\n * Annotated (but uninitialized) fields still have a type.\n */\n(o.annotatedField: number);\n(o.annotatedField: string); // Error: number ~> string\n(Base.annotatedField: number);\n(Base.annotatedField: string); // Error: number ~> string\n\n/**\n * Initialized (but unannotated) fields assume the type of their initializer.\n */\n(o.initializedField: number);\n(o.initializedField: string); // Error: number ~> string\n(Base.initializedField: string);\n(Base.initializedField: number); // Error: string ~> number\n\n/**\n * Initialized fields can reference `this`.\n */\n(o.initializedFieldWithThis: number);\n(o.initializedFieldWithThis: string); // Error: number ~> string\n(Base.initializedFieldWithThis: string);\n(Base.initializedFieldWithThis: number); // Error: string ~> number\n\n/**\n * Initialized + annotated fields take the type of the annotation.\n * (Note that this matters when the annotation is more general than the type of\n *  the initializer)\n */\n(o.annotatedInitializedFieldValid: ?number);\n(o.annotatedInitializedFieldValid: number); // Error: ?number ~> number\n(Base.annotatedInitializedFieldValid: ?number);\n(Base.annotatedInitializedFieldValid: number); // Error: ?number ~> number\n\n/**\n * Initialized + annotated fields where the init/annot combo is a mismatch\n * should assume the type of the annotation.\n *\n * (This happens in addition to erroring at the site of initialization)\n */\n(o.annotatedInitializedFieldInvalid: number);\n(o.annotatedInitializedFieldInvalid: string); // Error: number ~> string\n(Base.annotatedInitializedFieldInvalid: number);\n(Base.annotatedInitializedFieldInvalid: string); // Error: number ~> string") ? ;
    assert_eq ! (formatted , "// @flow\n\nclass Base {\n  unannotatedField;\n  annotatedField: number;\n  initializedField = 42;\n  initializedFieldWithThis = this.initializedField;\n  annotatedInitializedFieldValid: ?number = 42;\n  annotatedInitializedFieldInvalid: number = \"asdf\"; // Error: string ~> number\n\n  static unannotatedField;\n  static annotatedField: number;\n  static initializedField = \"asdf\";\n  static initializedFieldWithThis = this.initializedField;\n  static annotatedInitializedFieldValid: ?number = 42;\n  static annotatedInitializedFieldInvalid: number = \"asdf\"; // Error: string ~> number\n}\n\nvar o = new Base();\n\n/**\n * Unannotated fields are open.\n */\n(o.unannotatedField: string);\n(o.unannotatedField: number);\n(Base.unannotatedField: string);\n(Base.unannotatedField: number);\n\n/**\n * Annotated (but uninitialized) fields still have a type.\n */\n(o.annotatedField: number);\n(o.annotatedField: string); // Error: number ~> string\n(Base.annotatedField: number);\n(Base.annotatedField: string); // Error: number ~> string\n\n/**\n * Initialized (but unannotated) fields assume the type of their initializer.\n */\n(o.initializedField: number);\n(o.initializedField: string); // Error: number ~> string\n(Base.initializedField: string);\n(Base.initializedField: number); // Error: string ~> number\n\n/**\n * Initialized fields can reference `this`.\n */\n(o.initializedFieldWithThis: number);\n(o.initializedFieldWithThis: string); // Error: number ~> string\n(Base.initializedFieldWithThis: string);\n(Base.initializedFieldWithThis: number); // Error: string ~> number\n\n/**\n * Initialized + annotated fields take the type of the annotation.\n * (Note that this matters when the annotation is more general than the type of\n *  the initializer)\n */\n(o.annotatedInitializedFieldValid: ?number);\n(o.annotatedInitializedFieldValid: number); // Error: ?number ~> number\n(Base.annotatedInitializedFieldValid: ?number);\n(Base.annotatedInitializedFieldValid: number); // Error: ?number ~> number\n\n/**\n * Initialized + annotated fields where the init/annot combo is a mismatch\n * should assume the type of the annotation.\n *\n * (This happens in addition to erroring at the site of initialization)\n */\n(o.annotatedInitializedFieldInvalid: number);\n(o.annotatedInitializedFieldInvalid: string); // Error: number ~> string\n(Base.annotatedInitializedFieldInvalid: number);\n(Base.annotatedInitializedFieldInvalid: string); // Error: number ~> string");
    Ok(())
}
#[test]
fn test_derived_class_js_format_1_4fc1c2c6() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\nclass Base {\n  base_unannotatedField;\n  base_annotatedField: number;\n  base_initializedField = 42;\n  base_initializedFieldWithThis = this.base_initializedField;\n  base_annotatedInitializedFieldValid: ?number = 42;\n  base_annotatedInitializedFieldInvalid: number = 'asdf'; // Error: string ~> number\n\n  static base_unannotatedField;\n  static base_annotatedField: number;\n  static base_initializedField = 'asdf';\n  static base_initializedFieldWithThis = this.base_initializedField;\n  static base_annotatedInitializedFieldValid: ?number = 42;\n  static base_annotatedInitializedFieldInvalid: number = 'asdf'; // Error: string ~> number\n\n  inherited_initializer = 42;\n  static inherited_initializer = 42;\n}\n\nclass Child extends Base {\n  child_unannotatedField;\n  child_annotatedField: number;\n  child_initializedField = 42;\n  child_initializedFieldWithThis = this.child_initializedField;\n  child_annotatedInitializedFieldValid: ?number = 42;\n  child_annotatedInitializedFieldInvalid: number = 'asdf'; // Error: string ~> number\n\n  static child_unannotatedField;\n  static child_annotatedField: number;\n  static child_initializedField = 'asdf';\n  static child_initializedFieldWithThis = this.child_initializedField;\n  static child_annotatedInitializedFieldValid: ?number = 42;\n  static child_annotatedInitializedFieldInvalid: number = 'asdf'; // Error: string ~> number\n\n  inherited_initializer;\n  static inherited_initializer;\n}\n\nvar o = new Child();\n\n/**\n * Unannotated fields are open.\n */\n(o.base_unannotatedField: string);\n(o.base_unannotatedField: number);\n(Child.base_unannotatedField: string);\n(Child.base_unannotatedField: number);\n\n(o.child_unannotatedField: string);\n(o.child_unannotatedField: number);\n(Child.child_unannotatedField: string);\n(Child.child_unannotatedField: number);\n\n\n/**\n * Annotated (but uninitialized) fields still have a type.\n */\n(o.base_annotatedField: number);\n(o.base_annotatedField: string); // Error: number ~> string\n(Child.base_annotatedField: number);\n(Child.base_annotatedField: string); // Error: number ~> string\n\n(o.child_annotatedField: number);\n(o.child_annotatedField: string); // Error: number ~> string\n(Child.child_annotatedField: number);\n(Child.child_annotatedField: string); // Error: number ~> string\n\n/**\n * Initialized (but unannotated) fields assume the type of their initializer.\n */\n(o.base_initializedField: number);\n(o.base_initializedField: string); // Error: number ~> string\n(Child.base_initializedField: string);\n(Child.base_initializedField: number); // Error: string ~> number\n\n(o.child_initializedField: number);\n(o.child_initializedField: string); // Error: number ~> string\n(Child.child_initializedField: string);\n(Child.child_initializedField: number); // Error: string ~> number\n\n/**\n * Initialized fields can reference `this`.\n */\n(o.base_initializedFieldWithThis: number);\n(o.base_initializedFieldWithThis: string); // Error: number ~> string\n(Child.base_initializedFieldWithThis: string);\n(Child.base_initializedFieldWithThis: number); // Error: string ~> number\n\n(o.child_initializedFieldWithThis: number);\n(o.child_initializedFieldWithThis: string); // Error: number ~> string\n(Child.child_initializedFieldWithThis: string);\n(Child.child_initializedFieldWithThis: number); // Error: string ~> number\n\n/**\n * Initialized + annotated fields take the type of the annotation.\n * (Note that this matters when the annotation is more general than the type of\n *  the initializer)\n */\n(o.base_annotatedInitializedFieldValid: ?number);\n(o.base_annotatedInitializedFieldValid: number); // Error: ?number ~> number\n(Child.base_annotatedInitializedFieldValid: ?number);\n(Child.base_annotatedInitializedFieldValid: number); // Error: ?number ~> number\n\n(o.child_annotatedInitializedFieldValid: ?number);\n(o.child_annotatedInitializedFieldValid: number); // Error: ?number ~> number\n(Child.child_annotatedInitializedFieldValid: ?number);\n(Child.child_annotatedInitializedFieldValid: number); // Error: ?number ~> number\n\n/**\n * Initialized + annotated fields where the init/annot combo is a mismatch\n * should assume the type of the annotation.\n *\n * (This happens in addition to erroring at the site of initialization)\n */\n(o.base_annotatedInitializedFieldInvalid: number);\n(o.base_annotatedInitializedFieldInvalid: string); // Error: number ~> string\n(Child.base_annotatedInitializedFieldInvalid: number);\n(Child.base_annotatedInitializedFieldInvalid: string); // Error: number ~> string\n\n(o.child_annotatedInitializedFieldInvalid: number);\n(o.child_annotatedInitializedFieldInvalid: string); // Error: number ~> string\n(Child.child_annotatedInitializedFieldInvalid: number);\n(Child.child_annotatedInitializedFieldInvalid: string); // Error: number ~> string\n\n/**\n * Derived fields without an initializer that shadow base fields *with* an\n * initializer should have the type of the base field.\n */\n(o.inherited_initializer: number);\n(o.inherited_initializer: string); // Error: number ~> string\n(Child.inherited_initializer: number);\n(Child.inherited_initializer: string); // Error: number ~> string") ? ;
    assert_eq ! (formatted , "// @flow\n\nclass Base {\n  base_unannotatedField;\n  base_annotatedField: number;\n  base_initializedField = 42;\n  base_initializedFieldWithThis = this.base_initializedField;\n  base_annotatedInitializedFieldValid: ?number = 42;\n  base_annotatedInitializedFieldInvalid: number = \"asdf\"; // Error: string ~> number\n\n  static base_unannotatedField;\n  static base_annotatedField: number;\n  static base_initializedField = \"asdf\";\n  static base_initializedFieldWithThis = this.base_initializedField;\n  static base_annotatedInitializedFieldValid: ?number = 42;\n  static base_annotatedInitializedFieldInvalid: number = \"asdf\"; // Error: string ~> number\n\n  inherited_initializer = 42;\n  static inherited_initializer = 42;\n}\n\nclass Child extends Base {\n  child_unannotatedField;\n  child_annotatedField: number;\n  child_initializedField = 42;\n  child_initializedFieldWithThis = this.child_initializedField;\n  child_annotatedInitializedFieldValid: ?number = 42;\n  child_annotatedInitializedFieldInvalid: number = \"asdf\"; // Error: string ~> number\n\n  static child_unannotatedField;\n  static child_annotatedField: number;\n  static child_initializedField = \"asdf\";\n  static child_initializedFieldWithThis = this.child_initializedField;\n  static child_annotatedInitializedFieldValid: ?number = 42;\n  static child_annotatedInitializedFieldInvalid: number = \"asdf\"; // Error: string ~> number\n\n  inherited_initializer;\n  static inherited_initializer;\n}\n\nvar o = new Child();\n\n/**\n * Unannotated fields are open.\n */\n(o.base_unannotatedField: string);\n(o.base_unannotatedField: number);\n(Child.base_unannotatedField: string);\n(Child.base_unannotatedField: number);\n\n(o.child_unannotatedField: string);\n(o.child_unannotatedField: number);\n(Child.child_unannotatedField: string);\n(Child.child_unannotatedField: number);\n\n/**\n * Annotated (but uninitialized) fields still have a type.\n */\n(o.base_annotatedField: number);\n(o.base_annotatedField: string); // Error: number ~> string\n(Child.base_annotatedField: number);\n(Child.base_annotatedField: string); // Error: number ~> string\n\n(o.child_annotatedField: number);\n(o.child_annotatedField: string); // Error: number ~> string\n(Child.child_annotatedField: number);\n(Child.child_annotatedField: string); // Error: number ~> string\n\n/**\n * Initialized (but unannotated) fields assume the type of their initializer.\n */\n(o.base_initializedField: number);\n(o.base_initializedField: string); // Error: number ~> string\n(Child.base_initializedField: string);\n(Child.base_initializedField: number); // Error: string ~> number\n\n(o.child_initializedField: number);\n(o.child_initializedField: string); // Error: number ~> string\n(Child.child_initializedField: string);\n(Child.child_initializedField: number); // Error: string ~> number\n\n/**\n * Initialized fields can reference `this`.\n */\n(o.base_initializedFieldWithThis: number);\n(o.base_initializedFieldWithThis: string); // Error: number ~> string\n(Child.base_initializedFieldWithThis: string);\n(Child.base_initializedFieldWithThis: number); // Error: string ~> number\n\n(o.child_initializedFieldWithThis: number);\n(o.child_initializedFieldWithThis: string); // Error: number ~> string\n(Child.child_initializedFieldWithThis: string);\n(Child.child_initializedFieldWithThis: number); // Error: string ~> number\n\n/**\n * Initialized + annotated fields take the type of the annotation.\n * (Note that this matters when the annotation is more general than the type of\n *  the initializer)\n */\n(o.base_annotatedInitializedFieldValid: ?number);\n(o.base_annotatedInitializedFieldValid: number); // Error: ?number ~> number\n(Child.base_annotatedInitializedFieldValid: ?number);\n(Child.base_annotatedInitializedFieldValid: number); // Error: ?number ~> number\n\n(o.child_annotatedInitializedFieldValid: ?number);\n(o.child_annotatedInitializedFieldValid: number); // Error: ?number ~> number\n(Child.child_annotatedInitializedFieldValid: ?number);\n(Child.child_annotatedInitializedFieldValid: number); // Error: ?number ~> number\n\n/**\n * Initialized + annotated fields where the init/annot combo is a mismatch\n * should assume the type of the annotation.\n *\n * (This happens in addition to erroring at the site of initialization)\n */\n(o.base_annotatedInitializedFieldInvalid: number);\n(o.base_annotatedInitializedFieldInvalid: string); // Error: number ~> string\n(Child.base_annotatedInitializedFieldInvalid: number);\n(Child.base_annotatedInitializedFieldInvalid: string); // Error: number ~> string\n\n(o.child_annotatedInitializedFieldInvalid: number);\n(o.child_annotatedInitializedFieldInvalid: string); // Error: number ~> string\n(Child.child_annotatedInitializedFieldInvalid: number);\n(Child.child_annotatedInitializedFieldInvalid: string); // Error: number ~> string\n\n/**\n * Derived fields without an initializer that shadow base fields *with* an\n * initializer should have the type of the base field.\n */\n(o.inherited_initializer: number);\n(o.inherited_initializer: string); // Error: number ~> string\n(Child.inherited_initializer: number);\n(Child.inherited_initializer: string); // Error: number ~> string");
    Ok(())
}
#[test]
fn test_generic_class_js_format_1_f346f6b6() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\n/**\n * Fields annotated with a generic should assume a type once the type param\n * is instantiated.\n */\nclass ClassAnnotated<T> {\n  p: T;\n  static p: T;\n}\n\nvar o1 = new ClassAnnotated();\no1.p = 42;\n(o1.p: number);\n(o1.p: string); // Error: number ~> string\nClassAnnotated.p = 42;\n(ClassAnnotated.p: number);\n(ClassAnnotated.p: string); // Error: number ~> string\n\n\n/**\n * It's always an error to initialized a generically-typed field with an\n * expression of any type other than the generic itself.\n */\nclass ClassGenericInitialized<T, U> {\n  invalid: T = 42; // Error: number ~> Generic<T>\n  valid: T = ((42:any):T);\n\n  static invalid: T = 42; // Error: number ~> Generic<T>\n  static valid: T = ((42:any):T);\n}") ? ;
    assert_eq ! (formatted , "// @flow\n\n/**\n * Fields annotated with a generic should assume a type once the type param\n * is instantiated.\n */\nclass ClassAnnotated<T> {\n  p: T;\n  static p: T;\n}\n\nvar o1 = new ClassAnnotated();\no1.p = 42;\n(o1.p: number);\n(o1.p: string); // Error: number ~> string\nClassAnnotated.p = 42;\n(ClassAnnotated.p: number);\n(ClassAnnotated.p: string); // Error: number ~> string\n\n/**\n * It's always an error to initialized a generically-typed field with an\n * expression of any type other than the generic itself.\n */\nclass ClassGenericInitialized<T, U> {\n  invalid: T = 42; // Error: number ~> Generic<T>\n  valid: T = ((42: any): T);\n\n  static invalid: T = 42; // Error: number ~> Generic<T>\n  static valid: T = ((42: any): T);\n}");
    Ok(())
}
#[test]
fn test_scoping_js_format_1_cd402288() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\nvar someVar = 42;\n\nclass Foo {\n  outer = someVar;\n  selfTyped: Foo;\n  selfTypedInit = new Foo();\n\n  static outer = someVar;\n  static selfTyped: Foo;\n  static selfTypedInit = new Foo();\n\n  constructor() {\n    var someVar = 'asdf';\n  }\n}\n\n/**\n * Field initializers execute in a scope immediately under the scope outside the\n * class definition.\n */\n(new Foo().outer: number);\n(new Foo().outer: string); // Error: number ~> string\n(Foo.outer: number);\n(Foo.outer: string); // Error: number ~> string\n\n/**\n * Field initializers should be able to refer to the class type in their type\n * annotations.\n */\n(new Foo().selfTyped: Foo);\n(new Foo().selfTyped: number); // Error: Foo ~> number\n(Foo.selfTyped: Foo);\n(Foo.selfTyped: number); // Error: Foo ~> number\n\n(new Foo().selfTypedInit: Foo);\n(new Foo().selfTypedInit: number); // Error: Foo ~> number\n(Foo.selfTypedInit: Foo);\n(Foo.selfTypedInit: number); // Error: Foo ~> number") ? ;
    assert_eq ! (formatted , "// @flow\n\nvar someVar = 42;\n\nclass Foo {\n  outer = someVar;\n  selfTyped: Foo;\n  selfTypedInit = new Foo();\n\n  static outer = someVar;\n  static selfTyped: Foo;\n  static selfTypedInit = new Foo();\n\n  constructor() {\n    var someVar = \"asdf\";\n  }\n}\n\n/**\n * Field initializers execute in a scope immediately under the scope outside the\n * class definition.\n */\n(new Foo().outer: number);\n(new Foo().outer: string); // Error: number ~> string\n(Foo.outer: number);\n(Foo.outer: string); // Error: number ~> string\n\n/**\n * Field initializers should be able to refer to the class type in their type\n * annotations.\n */\n(new Foo().selfTyped: Foo);\n(new Foo().selfTyped: number); // Error: Foo ~> number\n(Foo.selfTyped: Foo);\n(Foo.selfTyped: number); // Error: Foo ~> number\n\n(new Foo().selfTypedInit: Foo);\n(new Foo().selfTypedInit: number); // Error: Foo ~> number\n(Foo.selfTypedInit: Foo);\n(Foo.selfTypedInit: number); // Error: Foo ~> number");
    Ok(())
}
