#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[allow(dead_code)]
static INFINITY: usize = usize::MAX;
#[test]
fn test_test_js_format_1_6fabf750() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parsers(vec!["flow"])
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("//@flow\nclass A {\n  #p: number\n  constructor() {this.#p = 3}\n}\n\nclass C {\n  #p: number\n  #q: number\n  constructor() {\n    this.#p = 0; // in scope\n    this.#q; // in scope\n  }\n  test(other: C) {\n    other.#q; // in lexical scope, object has the property.\n  }\n}\n\nclass D {\n  #p: number // Note that C also has a #p with number, and #p is in\n             // lexical scope\n  constructor() {this.#p = 3}\n  test(other: C) {\n    other.#p; // Error: other does not have access to private variables in here.\n  }\n}\n\nclass Outer {\n #outer: number\n constructor() {\n   var Inner = class A {\n      #inner: Outer\n      constructor() {\n        this.#inner = new Outer();\n        var x = new Outer();\n        x.#outer = 0; // Both inner and outer should be visible here!\n        x.#inner = new Outer(); // Error, #inner is not a private field of Outer\n      }\n   };\n }\n}\n\nclass Clash {\n  #p: number\n  constructor() {\n    var Inner = class A {\n      #p: string\n      constructor() {\n        (this.#p : number); // Error, #p is a string not a number\n        this.#p = \"test\";\n        this.#p = 3; // Error, #p is a string not a number\n        var x = new Clash();\n        (x.#p : string) // Error, here #p is a number not a string\n      }\n    }\n  }\n}\n\nclass Refinements {\n  #p: ?number\n  constructor () {\n    if (this.#p) {\n      (this.#p : number); // Refinements work properly\n    } else {\n      (this.#p : number); // Error #p is null or undefined\n    }\n  }\n}\n\nclass IncompatibleGetAndSet {\n  #p: number\n  static #q: number\n  constructor () {\n    const a: number = 3;\n    a.#p = 3; // Error, #p not on number\n    const b: {p: number} = {p: 3}\n    b.#p; // Error, #p not on b.\n  }\n}\n\nclass Static {\n  static #p: number\n  static #q: number\n  #r: number\n  m(): number {\n    Static.#p = 2;\n    if (Static.#p === 3) { // Refinements still work\n      (Static.#p : 3);\n    }\n    return Static.#p;\n  }\n bad() {\n   IncompatibleGetAndSet.#q; // Error, not visible here\n   Static.#q = Static.#p;\n   this.#p = 3; // Error, no #p on instance\n   this.#q; // Error, no #q on instance\n   Static.#r; // Error, no #r on class\n   Static.#r = Static.#q; // Error, no #r on class\n }\n}\n\nclass Annotations {\n  // Private class fields must either be annotated or have an initializer\n  #p: number;\n  #q = 0;\n  #r;\n  #s: string = 0; // Error, number ~> string\n  #t: string = \"yay!\";\n  static #sp: number;\n  static #sq = 0;\n  static #sr;\n  static #ss: string = 0; // Error, number ~> string\n  static #st: string = \"yay!\";\n  test1(): number {\n    return this.#p;\n  }\n  test2(): number {\n    return this.#t; // Error, string ~> number\n  }\n  test3(): number {\n    return Annotations.#sp;\n  }\n  test4(): number {\n    return Annotations.#st; // Error, string ~> number\n  }\n  test5(): number {\n    return this.#r;\n  }\n  test6(): string {\n    return this.#r; // Error, number ~> string\n  }\n  test5And6Helper() {\n    this.#r = 3;\n  }\n  test7(): number {\n    return Annotations.#sr;\n  }\n  test8(): string {\n    return Annotations.#sr; // Error, number ~> string\n  }\n  test7And9Helper() {\n    Annotations.#sr = 3;\n  }\n}\n\nclass RefinementClashes {\n  // Refinements on private fields can be considered separately from the\n  // rest of heap refinements\n #p: number;\n p: number;\n static q: number;\n static #q: number;\n test1() {\n   if (this.#p === 3) {\n     (this.p: 3); // Error, this.#p doesn't refine this.p\n     (this.#p: 3);\n     this.p = 4;\n     (this.p: 4);\n     (this.#p: 4); // Error, this.p doesnt refine this.#p\n     (this.#p: 3); // this.p doesnt havoc this.#p\n     this.#p = 3;\n     (this.p: 3); // Error, this.#p doesnt refine this.p\n     (this.p: 4); // this.#p doesnt havoc this.p\n   }\n   (this.#p: 3); // Error, Havoc happens as normal\n }\n test2() {\n   if (RefinementClashes.#q === 3) {\n     (RefinementClashes.q: 3); // Error, RefinementClashes.#q doesn't refine RefinementClashes.q\n     (RefinementClashes.#q: 3);\n     RefinementClashes.q = 4;\n     (RefinementClashes.q: 4);\n     (RefinementClashes.#q: 4); // Error, RefinementClashes.q doesnt refine RefinementClashes.#q\n     (RefinementClashes.#q: 3); // RefinementClashes.q doesnt havoc RefinementClashes.#q\n     RefinementClashes.#q = 3;\n     (RefinementClashes.q: 3); // Error, RefinementClashes.#q doesnt refine RefinementClashes.q\n     (RefinementClashes.q: 4); // RefinementClashes.#q doesnt havoc RefinementClashes.q\n   }\n   (RefinementClashes.#q: 3); // Error, Havoc happens as normal\n }\n test3(other: RefinementClashes) {\n   if (this.#p === 3) {\n     (this.#p: 3);\n     other.#p = 3;\n     (this.#p: 3); // Error, other.#p does havoc this.#p\n   }\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "//@flow\nclass A {\n  #p: number;\n  constructor() {\n    this.#p = 3;\n  }\n}\n\nclass C {\n  #p: number;\n  #q: number;\n  constructor() {\n    this.#p = 0; // in scope\n    this.#q; // in scope\n  }\n  test(other: C) {\n    other.#q; // in lexical scope, object has the property.\n  }\n}\n\nclass D {\n  #p: number; // Note that C also has a #p with number, and #p is in\n  // lexical scope\n  constructor() {\n    this.#p = 3;\n  }\n  test(other: C) {\n    other.#p; // Error: other does not have access to private variables in here.\n  }\n}\n\nclass Outer {\n  #outer: number;\n  constructor() {\n    var Inner = class A {\n      #inner: Outer;\n      constructor() {\n        this.#inner = new Outer();\n        var x = new Outer();\n        x.#outer = 0; // Both inner and outer should be visible here!\n        x.#inner = new Outer(); // Error, #inner is not a private field of Outer\n      }\n    };\n  }\n}\n\nclass Clash {\n  #p: number;\n  constructor() {\n    var Inner = class A {\n      #p: string;\n      constructor() {\n        (this.#p: number); // Error, #p is a string not a number\n        this.#p = \"test\";\n        this.#p = 3; // Error, #p is a string not a number\n        var x = new Clash();\n        (x.#p: string); // Error, here #p is a number not a string\n      }\n    };\n  }\n}\n\nclass Refinements {\n  #p: ?number;\n  constructor() {\n    if (this.#p) {\n      (this.#p: number); // Refinements work properly\n    } else {\n      (this.#p: number); // Error #p is null or undefined\n    }\n  }\n}\n\nclass IncompatibleGetAndSet {\n  #p: number;\n  static #q: number;\n  constructor() {\n    const a: number = 3;\n    a.#p = 3; // Error, #p not on number\n    const b: { p: number } = { p: 3 };\n    b.#p; // Error, #p not on b.\n  }\n}\n\nclass Static {\n  static #p: number;\n  static #q: number;\n  #r: number;\n  m(): number {\n    Static.#p = 2;\n    if (Static.#p === 3) {\n      // Refinements still work\n      (Static.#p: 3);\n    }\n    return Static.#p;\n  }\n  bad() {\n    IncompatibleGetAndSet.#q; // Error, not visible here\n    Static.#q = Static.#p;\n    this.#p = 3; // Error, no #p on instance\n    this.#q; // Error, no #q on instance\n    Static.#r; // Error, no #r on class\n    Static.#r = Static.#q; // Error, no #r on class\n  }\n}\n\nclass Annotations {\n  // Private class fields must either be annotated or have an initializer\n  #p: number;\n  #q = 0;\n  #r;\n  #s: string = 0; // Error, number ~> string\n  #t: string = \"yay!\";\n  static #sp: number;\n  static #sq = 0;\n  static #sr;\n  static #ss: string = 0; // Error, number ~> string\n  static #st: string = \"yay!\";\n  test1(): number {\n    return this.#p;\n  }\n  test2(): number {\n    return this.#t; // Error, string ~> number\n  }\n  test3(): number {\n    return Annotations.#sp;\n  }\n  test4(): number {\n    return Annotations.#st; // Error, string ~> number\n  }\n  test5(): number {\n    return this.#r;\n  }\n  test6(): string {\n    return this.#r; // Error, number ~> string\n  }\n  test5And6Helper() {\n    this.#r = 3;\n  }\n  test7(): number {\n    return Annotations.#sr;\n  }\n  test8(): string {\n    return Annotations.#sr; // Error, number ~> string\n  }\n  test7And9Helper() {\n    Annotations.#sr = 3;\n  }\n}\n\nclass RefinementClashes {\n  // Refinements on private fields can be considered separately from the\n  // rest of heap refinements\n  #p: number;\n  p: number;\n  static q: number;\n  static #q: number;\n  test1() {\n    if (this.#p === 3) {\n      (this.p: 3); // Error, this.#p doesn't refine this.p\n      (this.#p: 3);\n      this.p = 4;\n      (this.p: 4);\n      (this.#p: 4); // Error, this.p doesnt refine this.#p\n      (this.#p: 3); // this.p doesnt havoc this.#p\n      this.#p = 3;\n      (this.p: 3); // Error, this.#p doesnt refine this.p\n      (this.p: 4); // this.#p doesnt havoc this.p\n    }\n    (this.#p: 3); // Error, Havoc happens as normal\n  }\n  test2() {\n    if (RefinementClashes.#q === 3) {\n      (RefinementClashes.q: 3); // Error, RefinementClashes.#q doesn't refine RefinementClashes.q\n      (RefinementClashes.#q: 3);\n      RefinementClashes.q = 4;\n      (RefinementClashes.q: 4);\n      (RefinementClashes.#q: 4); // Error, RefinementClashes.q doesnt refine RefinementClashes.#q\n      (RefinementClashes.#q: 3); // RefinementClashes.q doesnt havoc RefinementClashes.#q\n      RefinementClashes.#q = 3;\n      (RefinementClashes.q: 3); // Error, RefinementClashes.#q doesnt refine RefinementClashes.q\n      (RefinementClashes.q: 4); // RefinementClashes.#q doesnt havoc RefinementClashes.q\n    }\n    (RefinementClashes.#q: 3); // Error, Havoc happens as normal\n  }\n  test3(other: RefinementClashes) {\n    if (this.#p === 3) {\n      (this.#p: 3);\n      other.#p = 3;\n      (this.#p: 3); // Error, other.#p does havoc this.#p\n    }\n  }\n}");
}
