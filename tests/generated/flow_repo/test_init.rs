#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[allow(dead_code)]
static INFINITY: usize = usize::MAX;
#[test]
fn test_hoisted_js_format_1_c27f7c3a() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parsers(vec!["flow"])
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/**\n * test initialization tracking in the presence of hoisting\n * @flow\n */\n\nfunction _if(b: () => boolean) {\n  if (b()) {\n    var f = function () {};\n  }\n  f(); // error, possibly undefined\n}\n\nfunction _while(b: () => boolean) {\n  while (b()) {\n    var f = function () {};\n  }\n  f(); // error, possibly undefined\n}\n\nfunction _do_while(b: () => boolean) {\n  do {\n    var f = function () {};\n  } while (b());\n  f(); // ok\n}\n\nfunction _for(n: number) {\n  for (var i = 0; i < n; i++) {\n    var f = function () {};\n  }\n  f(); // error, possibly undefined\n}\n\nfunction _for_in(obj: Object) {\n  for (var p in obj) {\n    var f = function () {};\n  }\n  f(); // error, possibly undefined\n}\n\nfunction _for_of(arr: Array<number>) {\n  for (var x of arr) {\n    var f = function () {};\n  }\n  f(); // error, possibly undefined\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/**\n * test initialization tracking in the presence of hoisting\n * @flow\n */\n\nfunction _if(b: () => boolean) {\n  if (b()) {\n    var f = function () {};\n  }\n  f(); // error, possibly undefined\n}\n\nfunction _while(b: () => boolean) {\n  while (b()) {\n    var f = function () {};\n  }\n  f(); // error, possibly undefined\n}\n\nfunction _do_while(b: () => boolean) {\n  do {\n    var f = function () {};\n  } while (b());\n  f(); // ok\n}\n\nfunction _for(n: number) {\n  for (var i = 0; i < n; i++) {\n    var f = function () {};\n  }\n  f(); // error, possibly undefined\n}\n\nfunction _for_in(obj: Object) {\n  for (var p in obj) {\n    var f = function () {};\n  }\n  f(); // error, possibly undefined\n}\n\nfunction _for_of(arr: Array<number>) {\n  for (var x of arr) {\n    var f = function () {};\n  }\n  f(); // error, possibly undefined\n}");
}
#[test]
fn test_hoisted_2_js_format_1_979bf16b() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parsers(vec!["flow"])
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/**\n * test initialization tracking for vars\n * note: for try/catch/finally, see tests/try/init.js\n * @flow\n */\n\n// deferred init on annotated vars is ok\nfunction linear_deferred_init() {\n  var x:number;\n  x = 0;\n  var y:number = x;\n}\n\n// ...but use of var before init gives undefined\nfunction linear_pre_init() {\n  var x:number;\n  var y:number = x; // error\n}\n\n// local use of annotated vars in an if is ok\nfunction if_scoped_init(b) {\n  if (b) {\n    var x:number = 0;\n    var y:number = x;\n  }\n}\n\n// but not across if/else\nfunction if_else_partial_init(b) {\n  if (b) {\n    var x:number = 0;\n  } else {\n    var y:number = x; // error\n  }\n}\n\n// use of var before if gives undefined\nfunction if_pre_init(b) {\n  var y:number = x; // error\n  if (b) {\n    var x:number = 0;\n  }\n}\n\n// ...and after\nfunction if_partial_post_init(b) {\n  if (b) {\n    var x:number = 0;\n  }\n  var y:number = x; // error\n}\n\n// ...unless both branches have initialized\nfunction if_post_init(b) {\n  if (b) {\n    var x:number = 0;\n  } else {\n    var x:number = 1;\n  }\n  var y:number = x;\n}\n\n// use of var after partial init (non-exhaustive if) gives undefined\nfunction if_partial_post_init(b) {\n  var x:number;\n  if (b) {\n    x = 0;\n  }\n  var y:number = x; // error, possibly uninitialized\n}\n\n// use of var after guaranteed init (exhaustive if) is ok\nfunction if_post_init(b) {\n  var x:number;\n  if (b) {\n    x = 0;\n  } else {\n    x = 1;\n  }\n  var y:number = x;\n}\n\n// use of var after partial init (non-exhaustive switch) gives undefined\nfunction switch_partial_post_init(i) {\n  var x:number;\n  switch (i) {\n    case 0:\n      x = 0;\n      break;\n    case 1:\n      x = 1;\n      break;\n  }\n  var y:number = x; // error, possibly uninitialized\n}\n\n// use of var after guaranteed init (exhaustive switch) is ok\nfunction switch_post_init(i) {\n  var x:number;\n  switch (i) {\n    case 0:\n      x = 0;\n      break;\n    case 1:\n      x = 1;\n      break;\n    default:\n      x = 2;\n  }\n  var y:number = x; // no error, all cases covered\n}\n\n// local use of annotated var in switch is ok\nfunction switch_scoped_init_1(i) {\n  switch (i) {\n    case 0:\n      var x:number = 0;\n      var y:number = x;\n  }\n}\n\n// ...but use of var before switch gives undefined\nfunction switch_scoped_init_2(i) {\n  var y:number = x; // error\n  switch (i) {\n    case 0:\n      var x:number = 0;\n  }\n}\n\n// ...and after\nfunction switch_scoped_init_3(i) {\n  switch (i) {\n    case 0:\n      var x:number = 0;\n  }\n  var y:number = x; // error\n}\n\n// ...and in a fallthrough case without initialization\nfunction switch_scoped_init_4(i) {\n  switch (i) {\n    case 0:\n      var x:number = 0;\n    case 1:\n      var y:number = x; // error\n  }\n}\n\n// local use of annotated var in while is ok\nfunction while_scoped_init(b) {\n  while (b) {\n    var x:number = 0;\n    var y:number = x;\n  }\n}\n\n// ...but use of var before while gives undefined\nfunction while_pre_init(b) {\n  var y:number = x; // error\n  while (b) {\n    var x:number = 0;\n  }\n}\n\n// ...and after\nfunction while_post_init(b) {\n   while (b) {\n    var x:number = 0;\n  }\n  var y:number = x; // error\n}\n\n// local use of annotated var in do-while is ok\nfunction do_while_scoped_init(b) {\n  do {\n    var x:number = 0;\n    var y:number = x;\n  } while (b);\n}\n\n// ...but use before do-while gives undefined\nfunction do_while_pre_init(b) {\n  var y:number = x; // error\n  do {\n    var x:number = 0;\n  } while (b);\n}\n\n// after is ok, because loop is guaranteed to run\nfunction do_while_post_init(b) {\n  do {\n    var x:number = 0;\n  } while (b);\n  var y:number = x;\n}\n\n// local use of annotated var in for is ok\nfunction for_scoped_init(b) {\n  for (;b;) {\n    var x:number = 0;\n    var y:number = x;\n  }\n}\n\n// ...but use before for gives undefined\nfunction for_pre_init(b) {\n  var y:number = x; // error\n  for (;b;) {\n    var x:number = 0;\n  }\n}\n\n// ...and after\nfunction for_post_init(b) {\n   for (;b;) {\n    var x:number = 0;\n  }\n  var y:number = x; // error\n}\n\n// local use of annotated var in for-in is ok\nfunction for_in_scoped_init() {\n  for (var p in { a:1, b: 2 }) {\n    var x:number = 0;\n    var y:number = x;\n  }\n}\n\n// ...but use before while gives undefined\nfunction for_in_pre_init() {\n  var y:number = x; // error\n  for (var p in { a:1, b: 2 }) {\n    var x:number = 0;\n  }\n}\n\n// ...and after\nfunction for_in_post_init() {\n  for (var p in { a:1, b: 2 }) {\n    var x:number = 0;\n  }\n  var y:number = x; // error\n}\n\n// local use of annotated var in for-of is ok\nfunction for_of_scoped_init() {\n  for (var x of [1, 2, 3]) {\n    var x:number = 0;\n    var y:number = x;\n  }\n}\n\n// ...but use before while gives undefined\nfunction for_in_pre_init() {\n  var y:number = x; // error\n  for (var x of [1, 2, 3]) {\n    var x:number = 0;\n  }\n}\n\n// ...and after\nfunction for_in_post_init() {\n  for (var x of [1, 2, 3]) {\n    var x:number = 0;\n  }\n  var y:number = x; // error\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/**\n * test initialization tracking for vars\n * note: for try/catch/finally, see tests/try/init.js\n * @flow\n */\n\n// deferred init on annotated vars is ok\nfunction linear_deferred_init() {\n  var x: number;\n  x = 0;\n  var y: number = x;\n}\n\n// ...but use of var before init gives undefined\nfunction linear_pre_init() {\n  var x: number;\n  var y: number = x; // error\n}\n\n// local use of annotated vars in an if is ok\nfunction if_scoped_init(b) {\n  if (b) {\n    var x: number = 0;\n    var y: number = x;\n  }\n}\n\n// but not across if/else\nfunction if_else_partial_init(b) {\n  if (b) {\n    var x: number = 0;\n  } else {\n    var y: number = x; // error\n  }\n}\n\n// use of var before if gives undefined\nfunction if_pre_init(b) {\n  var y: number = x; // error\n  if (b) {\n    var x: number = 0;\n  }\n}\n\n// ...and after\nfunction if_partial_post_init(b) {\n  if (b) {\n    var x: number = 0;\n  }\n  var y: number = x; // error\n}\n\n// ...unless both branches have initialized\nfunction if_post_init(b) {\n  if (b) {\n    var x: number = 0;\n  } else {\n    var x: number = 1;\n  }\n  var y: number = x;\n}\n\n// use of var after partial init (non-exhaustive if) gives undefined\nfunction if_partial_post_init(b) {\n  var x: number;\n  if (b) {\n    x = 0;\n  }\n  var y: number = x; // error, possibly uninitialized\n}\n\n// use of var after guaranteed init (exhaustive if) is ok\nfunction if_post_init(b) {\n  var x: number;\n  if (b) {\n    x = 0;\n  } else {\n    x = 1;\n  }\n  var y: number = x;\n}\n\n// use of var after partial init (non-exhaustive switch) gives undefined\nfunction switch_partial_post_init(i) {\n  var x: number;\n  switch (i) {\n    case 0:\n      x = 0;\n      break;\n    case 1:\n      x = 1;\n      break;\n  }\n  var y: number = x; // error, possibly uninitialized\n}\n\n// use of var after guaranteed init (exhaustive switch) is ok\nfunction switch_post_init(i) {\n  var x: number;\n  switch (i) {\n    case 0:\n      x = 0;\n      break;\n    case 1:\n      x = 1;\n      break;\n    default:\n      x = 2;\n  }\n  var y: number = x; // no error, all cases covered\n}\n\n// local use of annotated var in switch is ok\nfunction switch_scoped_init_1(i) {\n  switch (i) {\n    case 0:\n      var x: number = 0;\n      var y: number = x;\n  }\n}\n\n// ...but use of var before switch gives undefined\nfunction switch_scoped_init_2(i) {\n  var y: number = x; // error\n  switch (i) {\n    case 0:\n      var x: number = 0;\n  }\n}\n\n// ...and after\nfunction switch_scoped_init_3(i) {\n  switch (i) {\n    case 0:\n      var x: number = 0;\n  }\n  var y: number = x; // error\n}\n\n// ...and in a fallthrough case without initialization\nfunction switch_scoped_init_4(i) {\n  switch (i) {\n    case 0:\n      var x: number = 0;\n    case 1:\n      var y: number = x; // error\n  }\n}\n\n// local use of annotated var in while is ok\nfunction while_scoped_init(b) {\n  while (b) {\n    var x: number = 0;\n    var y: number = x;\n  }\n}\n\n// ...but use of var before while gives undefined\nfunction while_pre_init(b) {\n  var y: number = x; // error\n  while (b) {\n    var x: number = 0;\n  }\n}\n\n// ...and after\nfunction while_post_init(b) {\n  while (b) {\n    var x: number = 0;\n  }\n  var y: number = x; // error\n}\n\n// local use of annotated var in do-while is ok\nfunction do_while_scoped_init(b) {\n  do {\n    var x: number = 0;\n    var y: number = x;\n  } while (b);\n}\n\n// ...but use before do-while gives undefined\nfunction do_while_pre_init(b) {\n  var y: number = x; // error\n  do {\n    var x: number = 0;\n  } while (b);\n}\n\n// after is ok, because loop is guaranteed to run\nfunction do_while_post_init(b) {\n  do {\n    var x: number = 0;\n  } while (b);\n  var y: number = x;\n}\n\n// local use of annotated var in for is ok\nfunction for_scoped_init(b) {\n  for (; b; ) {\n    var x: number = 0;\n    var y: number = x;\n  }\n}\n\n// ...but use before for gives undefined\nfunction for_pre_init(b) {\n  var y: number = x; // error\n  for (; b; ) {\n    var x: number = 0;\n  }\n}\n\n// ...and after\nfunction for_post_init(b) {\n  for (; b; ) {\n    var x: number = 0;\n  }\n  var y: number = x; // error\n}\n\n// local use of annotated var in for-in is ok\nfunction for_in_scoped_init() {\n  for (var p in { a: 1, b: 2 }) {\n    var x: number = 0;\n    var y: number = x;\n  }\n}\n\n// ...but use before while gives undefined\nfunction for_in_pre_init() {\n  var y: number = x; // error\n  for (var p in { a: 1, b: 2 }) {\n    var x: number = 0;\n  }\n}\n\n// ...and after\nfunction for_in_post_init() {\n  for (var p in { a: 1, b: 2 }) {\n    var x: number = 0;\n  }\n  var y: number = x; // error\n}\n\n// local use of annotated var in for-of is ok\nfunction for_of_scoped_init() {\n  for (var x of [1, 2, 3]) {\n    var x: number = 0;\n    var y: number = x;\n  }\n}\n\n// ...but use before while gives undefined\nfunction for_in_pre_init() {\n  var y: number = x; // error\n  for (var x of [1, 2, 3]) {\n    var x: number = 0;\n  }\n}\n\n// ...and after\nfunction for_in_post_init() {\n  for (var x of [1, 2, 3]) {\n    var x: number = 0;\n  }\n  var y: number = x; // error\n}");
}
#[test]
fn test_let_js_format_1_b954e969() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parsers(vec!["flow"])
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/**\n * test initialization tracking for lets\n * @flow\n */\n\n// deferred init on annotated lets is ok\nfunction linear_deferred_init() {\n  let x:number;\n  x = 0;\n  let y:number = x;\n}\n\n// use of let before init gives undefined\nfunction linear_pre_init() {\n  let x:number;\n  let y:?number = x;  // ok\n  let z:number = x;   // error\n  x = 0;\n  let w:number = x;   // ok\n}\n\n// self-references in let bindings are not ok\nfunction self_init() {\n  let x = x;  // 'x' not initialized!\n}\n\n// use of let after partial init (non-exhaustive if) gives undefined\nfunction if_partial_post_init(b) {\n  let x:number;\n  if (b) {\n    x = 0;\n  }\n  var y:number = x; // error, possibly uninitialized\n}\n\n// use of let after guaranteed init (exhaustive if) is ok\nfunction if_post_init(b) {\n  let x:number;\n  if (b) {\n    x = 0;\n  } else {\n    x = 1;\n  }\n  var y:number = x;\n}\n\n// use of let after partial init (non-exhaustive switch) gives undefined\nfunction switch_partial_post_init(i) {\n  let x:number;\n  switch (i) {\n    case 0:\n      x = 0;\n      break;\n    case 1:\n      x = 1;\n      break;\n  }\n  var y:number = x; // error, possibly uninitialized\n}\n\n// use of let after guaranteed init (exhaustive switch) is ok\nfunction switch_post_init(i) {\n  let x:number;\n  switch (i) {\n    case 0:\n      x = 0;\n      break;\n    case 1:\n      x = 1;\n      break;\n    default:\n      x = 2;\n  }\n  var y:number = x; // no error, all cases covered\n}\n\n// use in a switch after a skipped decl is an error\nfunction switch_scoped_init_2(i) {\n  switch (i) {\n    case 0:\n      let x:number;\n    case 1:\n      let y:number = x; // error, skipped declaration\n  }\n}\n\n// while leaves it possibly uninitialized\nfunction while_post_init(b) {\n  let x:number;\n  while (b) {\n    x = 0;\n  }\n  var y:number = x; // error\n}\n\n// do-while is ok, because loop is guaranteed to run at least once\nfunction do_while_post_init(b) {\n  let x:number;\n  do {\n    x = 0;\n  } while (b);\n  var y:number = x; // ok\n}\n\n// for-in leaves it possibly uninitialized\nfunction for_in_post_init() {\n  var x:number;\n  for (var p in {}) {\n    x = 0;\n  }\n  var y:number = x; // error\n}\n\n// for-of leaves it possibly uninitialized\nfunction for_of_post_init() {\n  var x:number;\n  for (var x of []) {\n    x = 0;\n  }\n  var y:number = x; // error\n}\n\n// use of let after guaranteed init (exhaustive switch + throw) is ok\nfunction switch_post_init2(i): number {\n  let bar;\n  switch (i) {\n    case 1:\n      bar = 3;\n      break;\n    default:\n      throw new Error('Invalid state');\n  }\n  return bar; // ok, definitely initialized\n}\n\n// use of let after guaranteed init (exhaustive switch + throw) is ok\nfunction switch_post_init2(i): number {\n  let bar;\n  switch (i) {\n    case 1:\n      bar = 3;\n      break;\n    default:\n      throw new Error('Invalid state');\n  }\n  return bar; // ok, definitely initialized\n}\n\n// reference of a let-binding is permitted in a sub-closure within the init expr\nfunction sub_closure_init_reference() {\n  let x = function() { return x; };\n  const y = function() { return y; };\n\n  // var-bindings can reference each other cyclically since they do not incur a\n  // TDZ (...even though this is weird...)\n  var z = z;\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/**\n * test initialization tracking for lets\n * @flow\n */\n\n// deferred init on annotated lets is ok\nfunction linear_deferred_init() {\n  let x: number;\n  x = 0;\n  let y: number = x;\n}\n\n// use of let before init gives undefined\nfunction linear_pre_init() {\n  let x: number;\n  let y: ?number = x; // ok\n  let z: number = x; // error\n  x = 0;\n  let w: number = x; // ok\n}\n\n// self-references in let bindings are not ok\nfunction self_init() {\n  let x = x; // 'x' not initialized!\n}\n\n// use of let after partial init (non-exhaustive if) gives undefined\nfunction if_partial_post_init(b) {\n  let x: number;\n  if (b) {\n    x = 0;\n  }\n  var y: number = x; // error, possibly uninitialized\n}\n\n// use of let after guaranteed init (exhaustive if) is ok\nfunction if_post_init(b) {\n  let x: number;\n  if (b) {\n    x = 0;\n  } else {\n    x = 1;\n  }\n  var y: number = x;\n}\n\n// use of let after partial init (non-exhaustive switch) gives undefined\nfunction switch_partial_post_init(i) {\n  let x: number;\n  switch (i) {\n    case 0:\n      x = 0;\n      break;\n    case 1:\n      x = 1;\n      break;\n  }\n  var y: number = x; // error, possibly uninitialized\n}\n\n// use of let after guaranteed init (exhaustive switch) is ok\nfunction switch_post_init(i) {\n  let x: number;\n  switch (i) {\n    case 0:\n      x = 0;\n      break;\n    case 1:\n      x = 1;\n      break;\n    default:\n      x = 2;\n  }\n  var y: number = x; // no error, all cases covered\n}\n\n// use in a switch after a skipped decl is an error\nfunction switch_scoped_init_2(i) {\n  switch (i) {\n    case 0:\n      let x: number;\n    case 1:\n      let y: number = x; // error, skipped declaration\n  }\n}\n\n// while leaves it possibly uninitialized\nfunction while_post_init(b) {\n  let x: number;\n  while (b) {\n    x = 0;\n  }\n  var y: number = x; // error\n}\n\n// do-while is ok, because loop is guaranteed to run at least once\nfunction do_while_post_init(b) {\n  let x: number;\n  do {\n    x = 0;\n  } while (b);\n  var y: number = x; // ok\n}\n\n// for-in leaves it possibly uninitialized\nfunction for_in_post_init() {\n  var x: number;\n  for (var p in {}) {\n    x = 0;\n  }\n  var y: number = x; // error\n}\n\n// for-of leaves it possibly uninitialized\nfunction for_of_post_init() {\n  var x: number;\n  for (var x of []) {\n    x = 0;\n  }\n  var y: number = x; // error\n}\n\n// use of let after guaranteed init (exhaustive switch + throw) is ok\nfunction switch_post_init2(i): number {\n  let bar;\n  switch (i) {\n    case 1:\n      bar = 3;\n      break;\n    default:\n      throw new Error(\"Invalid state\");\n  }\n  return bar; // ok, definitely initialized\n}\n\n// use of let after guaranteed init (exhaustive switch + throw) is ok\nfunction switch_post_init2(i): number {\n  let bar;\n  switch (i) {\n    case 1:\n      bar = 3;\n      break;\n    default:\n      throw new Error(\"Invalid state\");\n  }\n  return bar; // ok, definitely initialized\n}\n\n// reference of a let-binding is permitted in a sub-closure within the init expr\nfunction sub_closure_init_reference() {\n  let x = function () {\n    return x;\n  };\n  const y = function () {\n    return y;\n  };\n\n  // var-bindings can reference each other cyclically since they do not incur a\n  // TDZ (...even though this is weird...)\n  var z = z;\n}");
}
#[test]
fn test_nullable_init_js_format_1_db979bcb() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parsers(vec!["flow"])
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer
        .format("var o: {x: ?number} = { x: null };\nvar a: Array<?number> = [null,null];");
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq!(
        formatted,
        "var o: { x: ?number } = { x: null };\nvar a: Array<?number> = [null, null];"
    );
}
