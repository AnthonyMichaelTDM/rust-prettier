#[allow(unused_imports)]
use anyhow::Result;
#[allow(unused_imports)]
use pretty_assertions::assert_eq;
#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[allow(dead_code)]
static INFINITY: usize = usize::MAX;
#[test]
fn test_apply_js_format_1_2b1736ef() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("function test(a: string, b: number): number {\n  return this.length; // expect []/\"\" this\n}\n\n// tuples flow correctly into params\ntest.apply(\"\", [\"\", 0]);\n\n// wrong this is an error\ntest.apply(0, [\"\", 0]); // error: lookup \\`length\\` on Number\n\n// not enough arguments is an error\ntest.apply(\"\", [\"\"]); // error: void ~> number\n\n// mistyped arguments is an error\ntest.apply(\"\", [\"\", \"\"]); // error: string ~> number (2nd arg)\ntest.apply(\"\", [0, 0]); // error: number ~> string (1st arg)\n\n// resolve args array from tvar\nfunction f(args) { test.apply(\"\", args) }\nf([\"\", 0]); // OK\nf([\"\", \"\"]); // error: string ~> number (2nd arg)\nf([0, 0]); // error: number ~> string (1st arg)\n\n// expect array\ntest.apply(\"\", \"not array\"); // error: expect array of args\n\n// expect 4 errors:\n// - lookup length on Number (because 0 is used as \\`this\\`)\n// - 123 is not a string\n// - 'foo' is not a number\n// - return type (number) is not void\n(test.call.apply(test, [0, 123, 'foo']): void);\n\n// expect 2 errors:\n// - lookup length on number (0 is used as \\`this\\`)\n// - 123 is not a string\n(test.bind.apply(test, [0, 123]): (b: number) => number);\n\n// args are optional\nfunction test2(): number { return 0; }\n(test2.apply(): number);\n(test2.apply(\"\"): number);\n\n// callable objects\nfunction test3(x: { (a: string, b: string): void }) {\n  x.apply(x, ['foo', 'bar']); // ok\n  x.apply(x, ['foo', 123]); // error, number !~> string\n}") ? ;
    assert_eq ! (formatted , "function test(a: string, b: number): number {\n  return this.length; // expect []/\"\" this\n}\n\n// tuples flow correctly into params\ntest.apply(\"\", [\"\", 0]);\n\n// wrong this is an error\ntest.apply(0, [\"\", 0]); // error: lookup \\`length\\` on Number\n\n// not enough arguments is an error\ntest.apply(\"\", [\"\"]); // error: void ~> number\n\n// mistyped arguments is an error\ntest.apply(\"\", [\"\", \"\"]); // error: string ~> number (2nd arg)\ntest.apply(\"\", [0, 0]); // error: number ~> string (1st arg)\n\n// resolve args array from tvar\nfunction f(args) {\n  test.apply(\"\", args);\n}\nf([\"\", 0]); // OK\nf([\"\", \"\"]); // error: string ~> number (2nd arg)\nf([0, 0]); // error: number ~> string (1st arg)\n\n// expect array\ntest.apply(\"\", \"not array\"); // error: expect array of args\n\n// expect 4 errors:\n// - lookup length on Number (because 0 is used as \\`this\\`)\n// - 123 is not a string\n// - 'foo' is not a number\n// - return type (number) is not void\n(test.call.apply(test, [0, 123, \"foo\"]): void);\n\n// expect 2 errors:\n// - lookup length on number (0 is used as \\`this\\`)\n// - 123 is not a string\n(test.bind.apply(test, [0, 123]): (b: number) => number);\n\n// args are optional\nfunction test2(): number {\n  return 0;\n}\n(test2.apply(): number);\n(test2.apply(\"\"): number);\n\n// callable objects\nfunction test3(x: { (a: string, b: string): void }) {\n  x.apply(x, [\"foo\", \"bar\"]); // ok\n  x.apply(x, [\"foo\", 123]); // error, number !~> string\n}");
    Ok(())
}
#[test]
fn test_bind_js_format_1_20b3bc9f() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\nlet tests = [\n  function(x: (a: string, b: string) => void) {\n    let y = x.bind(x, 'foo');\n    y('bar'); // ok\n    y(123); // error, number !~> string\n  },\n\n  // callable objects\n  function(x: { (a: string, b: string): void }) {\n    let y = x.bind(x, 'foo');\n    y('bar'); // ok\n    y(123); // error, number !~> string\n  },\n\n  // non-callable objects\n  function(x: { a: string }) {\n    x.bind(x, 'foo'); // error\n  },\n\n  // callable objects with overridden \\`bind\\` method\n  function(x: {(a: string, b: string): void, bind(a: string): void}) {\n    (x.bind('foo'): void); // ok\n    (x.bind(123): void); // error, number !~> string\n  },\n\n];") ? ;
    assert_eq ! (formatted , "// @flow\n\nlet tests = [\n  function (x: (a: string, b: string) => void) {\n    let y = x.bind(x, \"foo\");\n    y(\"bar\"); // ok\n    y(123); // error, number !~> string\n  },\n\n  // callable objects\n  function (x: { (a: string, b: string): void }) {\n    let y = x.bind(x, \"foo\");\n    y(\"bar\"); // ok\n    y(123); // error, number !~> string\n  },\n\n  // non-callable objects\n  function (x: { a: string }) {\n    x.bind(x, \"foo\"); // error\n  },\n\n  // callable objects with overridden \\`bind\\` method\n  function (x: { (a: string, b: string): void, bind(a: string): void }) {\n    (x.bind(\"foo\"): void); // ok\n    (x.bind(123): void); // error, number !~> string\n  },\n];");
    Ok(())
}
#[test]
fn test_call_js_format_1_f9dfec3d() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\nfunction test(a: string, b: number): number {\n  return this.length; // expect []/\"\" this\n}\n\n// args flow correctly into params\ntest.call(\"\", \"\", 0);\n\n// wrong this is an error\ntest.call(0, \"\", 0); // error: lookup \\`length\\` on Number\n\n// not enough arguments is an error\ntest.call(\"\", \"\"); // error: void ~> number\n\n// mistyped arguments is an error\ntest.call(\"\", \"\", \"\"); // error: string ~> number (2nd arg)\ntest.call(\"\", 0, 0); // error: number ~> string (1st arg)\n\n// resolve args array from tvar\nfunction f(args) { test.call(\"\", args[0], args[1]) }\nf([\"\", 0]); // OK\nf([\"\", \"\"]); // error: string ~> number (2nd arg)\nf([0, 0]); // error: number ~> string (1st arg)\n\n// expect 3 errors:\n// - lookup length on Number (0 used as \\`this\\`)\n// - number !~> string (param a)\n// - string !~> number (param b)\n(test.apply.call(test, 0, [0, 'foo']): number);\n\n// args are optional\nfunction test2(): number { return 0; }\n(test2.call(): number);\n(test2.call(\"\"): number);\n\n// callable objects\nfunction test3(x: { (a: string, b: string): void }) {\n  x.call(x, 'foo', 'bar'); // ok\n  x.call(x, 'foo', 123); // error, number !~> string\n}") ? ;
    assert_eq ! (formatted , "// @flow\n\nfunction test(a: string, b: number): number {\n  return this.length; // expect []/\"\" this\n}\n\n// args flow correctly into params\ntest.call(\"\", \"\", 0);\n\n// wrong this is an error\ntest.call(0, \"\", 0); // error: lookup \\`length\\` on Number\n\n// not enough arguments is an error\ntest.call(\"\", \"\"); // error: void ~> number\n\n// mistyped arguments is an error\ntest.call(\"\", \"\", \"\"); // error: string ~> number (2nd arg)\ntest.call(\"\", 0, 0); // error: number ~> string (1st arg)\n\n// resolve args array from tvar\nfunction f(args) {\n  test.call(\"\", args[0], args[1]);\n}\nf([\"\", 0]); // OK\nf([\"\", \"\"]); // error: string ~> number (2nd arg)\nf([0, 0]); // error: number ~> string (1st arg)\n\n// expect 3 errors:\n// - lookup length on Number (0 used as \\`this\\`)\n// - number !~> string (param a)\n// - string !~> number (param b)\n(test.apply.call(test, 0, [0, \"foo\"]): number);\n\n// args are optional\nfunction test2(): number {\n  return 0;\n}\n(test2.call(): number);\n(test2.call(\"\"): number);\n\n// callable objects\nfunction test3(x: { (a: string, b: string): void }) {\n  x.call(x, \"foo\", \"bar\"); // ok\n  x.call(x, \"foo\", 123); // error, number !~> string\n}");
    Ok(())
}
#[test]
fn test_function_js_format_1_e74697c1() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/**\n * @flow\n */\n\n// Previously we represented Function as (...rest: any) => any\n// This means the following wouldn't pass, because that arrow function\n// can only be called with 3 arguments.\nvar a: Function = (a, b, c) => 123;\n\nvar b: Function = function(a: number, b: number): number { return a + b; };\n\nclass C {}\n\nvar c: Function = C;\n\nfunction good(x: Function, MyThing: Function): number {\n  var o: Object = x; // Function is an Object\n  x.foo = 123;\n  x['foo'] = 456;\n  x();\n  <MyThing />;\n  var {...something} = x;\n  Object.assign(x, {hi: 'there'});\n  Object.keys(x);\n  return x.bar + x['bar'] + x.lala();\n}\n\nfunction bad(x: Function, y: Object): void {\n  var a: number = x; // Error\n  var b: string = x; // Error\n  var c: Function = y; // Object is not a Function\n}\n\nlet tests = [\n  function(y: () => void, z: Function) {\n    function x() {}\n    (x.length: void); // error, it's a number\n    (y.length: void); // error, it's a number\n    (z.length: void); // error, it's a number\n\n    (x.name: void); // error, it's a string\n    (y.name: void); // error, it's a string\n    (z.name: void); // error, it's a string\n  },\n\n  function(y: () => void, z: Function) {\n    function x() {}\n    x.length = 'foo'; // error, it's a number\n    y.length = 'foo'; // error, it's a number\n    z.length = 'foo'; // error, it's a number\n\n    x.name = 123; // error, it's a string\n    y.name = 123; // error, it's a string\n    z.name = 123; // error, it's a string\n\n    // Non-(Function.prototype) properties on a \\`Function\\` type should be \\`any\\`\n    (z.foo: number);\n    (z.foo: string);\n  },\n];\n\n// \\`Function\\` types can be bound (resulting in a \\`Function\\` type)\nvar d: Function = () => 1;\nvar e = (d.bind(1): Function)();\n(e: number);\n(e: string);") ? ;
    assert_eq ! (formatted , "/**\n * @flow\n */\n\n// Previously we represented Function as (...rest: any) => any\n// This means the following wouldn't pass, because that arrow function\n// can only be called with 3 arguments.\nvar a: Function = (a, b, c) => 123;\n\nvar b: Function = function (a: number, b: number): number {\n  return a + b;\n};\n\nclass C {}\n\nvar c: Function = C;\n\nfunction good(x: Function, MyThing: Function): number {\n  var o: Object = x; // Function is an Object\n  x.foo = 123;\n  x[\"foo\"] = 456;\n  x();\n  <MyThing />;\n  var { ...something } = x;\n  Object.assign(x, { hi: \"there\" });\n  Object.keys(x);\n  return x.bar + x[\"bar\"] + x.lala();\n}\n\nfunction bad(x: Function, y: Object): void {\n  var a: number = x; // Error\n  var b: string = x; // Error\n  var c: Function = y; // Object is not a Function\n}\n\nlet tests = [\n  function (y: () => void, z: Function) {\n    function x() {}\n    (x.length: void); // error, it's a number\n    (y.length: void); // error, it's a number\n    (z.length: void); // error, it's a number\n\n    (x.name: void); // error, it's a string\n    (y.name: void); // error, it's a string\n    (z.name: void); // error, it's a string\n  },\n\n  function (y: () => void, z: Function) {\n    function x() {}\n    x.length = \"foo\"; // error, it's a number\n    y.length = \"foo\"; // error, it's a number\n    z.length = \"foo\"; // error, it's a number\n\n    x.name = 123; // error, it's a string\n    y.name = 123; // error, it's a string\n    z.name = 123; // error, it's a string\n\n    // Non-(Function.prototype) properties on a \\`Function\\` type should be \\`any\\`\n    (z.foo: number);\n    (z.foo: string);\n  },\n];\n\n// \\`Function\\` types can be bound (resulting in a \\`Function\\` type)\nvar d: Function = () => 1;\nvar e = (d.bind(1): Function)();\n(e: number);\n(e: string);");
    Ok(())
}
#[test]
fn test_rest_js_format_1_c1f22ed1() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* regression tests */\n\nfunction rest_array<T>(...xs: Array<T>): T { // Ok, arrays can be rest params\n  return xs[0];\n}\n\nfunction rest_tuple<T>(...xs: [T]): T { // Ok, tuples can be rest params\n  return xs[0];\n}\n\nfunction rest_ro_array<T>(...xs: $ReadOnlyArray<T>): T { // Ok\n  return xs[0];\n}\n\nfunction rest_any(...xs: any): any { // Ok, any can be a rest param\n  return xs[0];\n}\n\nfunction rest_t<U, T: Array<U>>(...xs: T): U { // Ok, bounded targ can be rest\n  return xs[0];\n}\n\n// These are ok bounds for the rest param\nfunction unbound_rest_t<T>(...xs: T): void {}\nfunction mixed_rest_t<T: mixed>(...xs: T): void {}\nfunction array_rest_t<T: Array<mixed>>(...xs: T): void {}\nfunction roarray_rest_t<T: $ReadOnlyArray<mixed>>(...xs: T): void {}\nfunction iterable_rest_t<T: Iterable<mixed>>(...xs: T): void {}\nfunction empty_rest_t<T: empty>(...xs: T): void {}\nfunction bounds_on_bounds<T>() {\n  return function<U: T>(...xs: T): void {}\n}\n\n// These are bad bounds for the rest param\nfunction bad_unbound_rest_t<T>(...xs: T): T {\n  return xs.pop(); // Error - no bound on T\n}\nfunction string_rest_t<T: string>(...xs: T): void {} // Error - rest param can't be a string\nfunction empty_rest_t<T: empty>(...xs: T): void {} // Error - rest param can't be empty\n\ntype Rest = Array<string>;\nfunction rest_alias(...xs: Rest): void {} // Ok\n\nfunction rest_union(...xs: [1,2] | Array<number>): number { // OK\n  return xs[0];\n}\n\nfunction rest_intersection(...xs: { x: number } & [1,2]): number { // OK\n  return xs[0] + xs.x;\n}\n\nfunction empty_rest<T:Array<mixed>>(...xs: T): T { return xs; }\n(empty_rest(): empty); // Error Array ~> empty\n\nfunction return_rest_param<Args:Array<mixed>>(\n  f: (...args: Args) => void,\n): (...args: Args) => number {\n  return function(...args) {\n    return args; // Error: Array ~> number\n  }\n}\n\nfunction requires_first_param(x: number, ...rest: Array<number>): void {}\nrequires_first_param(); // Error: missing first arg") ? ;
    assert_eq ! (formatted , "/* regression tests */\n\nfunction rest_array<T>(...xs: Array<T>): T {\n  // Ok, arrays can be rest params\n  return xs[0];\n}\n\nfunction rest_tuple<T>(...xs: [T]): T {\n  // Ok, tuples can be rest params\n  return xs[0];\n}\n\nfunction rest_ro_array<T>(...xs: $ReadOnlyArray<T>): T {\n  // Ok\n  return xs[0];\n}\n\nfunction rest_any(...xs: any): any {\n  // Ok, any can be a rest param\n  return xs[0];\n}\n\nfunction rest_t<U, T: Array<U>>(...xs: T): U {\n  // Ok, bounded targ can be rest\n  return xs[0];\n}\n\n// These are ok bounds for the rest param\nfunction unbound_rest_t<T>(...xs: T): void {}\nfunction mixed_rest_t<T: mixed>(...xs: T): void {}\nfunction array_rest_t<T: Array<mixed>>(...xs: T): void {}\nfunction roarray_rest_t<T: $ReadOnlyArray<mixed>>(...xs: T): void {}\nfunction iterable_rest_t<T: Iterable<mixed>>(...xs: T): void {}\nfunction empty_rest_t<T: empty>(...xs: T): void {}\nfunction bounds_on_bounds<T>() {\n  return function <U: T>(...xs: T): void {};\n}\n\n// These are bad bounds for the rest param\nfunction bad_unbound_rest_t<T>(...xs: T): T {\n  return xs.pop(); // Error - no bound on T\n}\nfunction string_rest_t<T: string>(...xs: T): void {} // Error - rest param can't be a string\nfunction empty_rest_t<T: empty>(...xs: T): void {} // Error - rest param can't be empty\n\ntype Rest = Array<string>;\nfunction rest_alias(...xs: Rest): void {} // Ok\n\nfunction rest_union(...xs: [1, 2] | Array<number>): number {\n  // OK\n  return xs[0];\n}\n\nfunction rest_intersection(...xs: { x: number } & [1, 2]): number {\n  // OK\n  return xs[0] + xs.x;\n}\n\nfunction empty_rest<T: Array<mixed>>(...xs: T): T {\n  return xs;\n}\n(empty_rest(): empty); // Error Array ~> empty\n\nfunction return_rest_param<Args: Array<mixed>>(\n  f: (...args: Args) => void,\n): (...args: Args) => number {\n  return function (...args) {\n    return args; // Error: Array ~> number\n  };\n}\n\nfunction requires_first_param(x: number, ...rest: Array<number>): void {}\nrequires_first_param(); // Error: missing first arg");
    Ok(())
}
#[test]
fn test_rest_type_js_format_1_46a04f3c() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* regression tests */\n\ntype rest_array = <T>(...xs: Array<T>) => T; // Ok, arrays can be rest params\n\ntype rest_tuple = <T>(...xs: [T]) => T; // Ok, tuples can be rest params\n\ntype rest_ro_array = <T>(...xs: $ReadOnlyArray<T>) => T;  // Ok\n\ntype rest_any = (...xs: any) => any; // Ok, any can be a rest param\n\ntype rest_t = <U, T: Array<U>>(...xs: T) => U; // Ok, bounded targ can be rest\n\ntype unbound_rest_t = <T>(...xs: T) => void; // Should be error but no way to check yet :(\nfunction test_unbound_rest(f: <T>(x: T, ...xs: T) => void) {\n  f(123); // Error - number ~> array - luckily this errors\n}\n\ntype string_rest_t = (...xs: string) => void; // Should be error but no way to check yet :(\nfunction test_string_rest(f: string_rest_t) {\n  f('hello'); // Error - string ~> array - luckily this errors\n}\n\ntype Rest = Array<string>;\ntype rest_alias = (...xs: Rest) => void; // Ok\n\ntype rest_union = (...xs: [1,2] | Array<number>) => number; // OK\n\ntype rest_intersection = (...xs: { x: number } & [1,2]) => number; // OK\n\ntype empty_rest = <T:Array<mixed>>(...xs: T) => T; // OK\n((f: empty_rest) => (f(): empty)); // Error Array ~> empty") ? ;
    assert_eq ! (formatted , "/* regression tests */\n\ntype rest_array = <T>(...xs: Array<T>) => T; // Ok, arrays can be rest params\n\ntype rest_tuple = <T>(...xs: [T]) => T; // Ok, tuples can be rest params\n\ntype rest_ro_array = <T>(...xs: $ReadOnlyArray<T>) => T; // Ok\n\ntype rest_any = (...xs: any) => any; // Ok, any can be a rest param\n\ntype rest_t = <U, T: Array<U>>(...xs: T) => U; // Ok, bounded targ can be rest\n\ntype unbound_rest_t = <T>(...xs: T) => void; // Should be error but no way to check yet :(\nfunction test_unbound_rest(f: <T>(x: T, ...xs: T) => void) {\n  f(123); // Error - number ~> array - luckily this errors\n}\n\ntype string_rest_t = (...xs: string) => void; // Should be error but no way to check yet :(\nfunction test_string_rest(f: string_rest_t) {\n  f(\"hello\"); // Error - string ~> array - luckily this errors\n}\n\ntype Rest = Array<string>;\ntype rest_alias = (...xs: Rest) => void; // Ok\n\ntype rest_union = (...xs: [1, 2] | Array<number>) => number; // OK\n\ntype rest_intersection = (...xs: { x: number } & [1, 2]) => number; // OK\n\ntype empty_rest = <T: Array<mixed>>(...xs: T) => T; // OK\n(f: empty_rest) => (f(): empty); // Error Array ~> empty");
    Ok(())
}
