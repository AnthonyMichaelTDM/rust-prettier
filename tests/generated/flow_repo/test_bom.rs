#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[allow(dead_code)]
static INFINITY: usize = usize::MAX;
#[test]
fn test_form_data_js_format_1_cdc1bb0a() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parsers(vec!["flow"])
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\n// constructor\nconst a: FormData = new FormData(); // correct\nnew FormData(''); // incorrect\nnew FormData(document.createElement('input')); // incorrect\nnew FormData(document.createElement('form')); // correct\n\n// has\nconst b: boolean = a.has('foo'); // correct\n\n// get\nconst c: ?(string | File) = a.get('foo'); // correct\nconst d: string = a.get('foo'); // incorrect\nconst e: Blob = a.get('foo'); // incorrect\nconst f: ?(string | File | Blob) = a.get('foo'); // incorrect\na.get(2); // incorrect\n\n// getAll\nconst a1: Array<string | File> = a.getAll('foo'); // correct\nconst a2: Array<string | File | number> = a.getAll('foo'); // incorrect\nconst a3: Array<string | Blob | File> = a.getAll('foo'); // incorrect\na.getAll(23); // incorrect\n\n// set\na.set('foo', 'bar'); // correct\na.set('foo', {}); // incorrect\na.set(2, 'bar'); // incorrect\na.set('foo', 'bar', 'baz'); // incorrect\na.set('bar', new File([], 'q')) // correct\na.set('bar', new File([], 'q'), 'x') // correct\na.set('bar', new File([], 'q'), 2) // incorrect\na.set('bar', new Blob) // correct\na.set('bar', new Blob, 'x') // correct\na.set('bar', new Blob, 2) // incorrect\n\n// append\na.append('foo', 'bar'); // correct\na.append('foo', {}); // incorrect\na.append(2, 'bar'); // incorrect\na.append('foo', 'bar', 'baz'); // incorrect\na.append('foo', 'bar'); // correct\na.append('bar', new File([], 'q')) // correct\na.append('bar', new File([], 'q'), 'x') // correct\na.append('bar', new File([], 'q'), 2) // incorrect\na.append('bar', new Blob) // correct\na.append('bar', new Blob, 'x') // correct\na.append('bar', new Blob, 2) // incorrect\n\n// delete\na.delete('xx'); // correct\na.delete(3); // incorrect\n\n// keys\nfor (let x: string of a.keys()) {} // correct\nfor (let x: number of a.keys()) {} // incorrect\n\n// values\nfor (let x: string | File of a.values()) {} // correct\nfor (let x: string | File | Blob of a.values()) {} // incorrect\n\n// entries\nfor (let [x, y]: [string, string | File] of a.entries()) {} // correct\nfor (let [x, y]: [string, string | File | Blob] of a.entries()) {} // incorrect\nfor (let [x, y]: [number, string] of a.entries()) {} // incorrect\nfor (let [x, y]: [string, number] of a.entries()) {} // incorrect\nfor (let [x, y]: [number, number] of a.entries()) {} // incorrect") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\n// constructor\nconst a: FormData = new FormData(); // correct\nnew FormData(\"\"); // incorrect\nnew FormData(document.createElement(\"input\")); // incorrect\nnew FormData(document.createElement(\"form\")); // correct\n\n// has\nconst b: boolean = a.has(\"foo\"); // correct\n\n// get\nconst c: ?(string | File) = a.get(\"foo\"); // correct\nconst d: string = a.get(\"foo\"); // incorrect\nconst e: Blob = a.get(\"foo\"); // incorrect\nconst f: ?(string | File | Blob) = a.get(\"foo\"); // incorrect\na.get(2); // incorrect\n\n// getAll\nconst a1: Array<string | File> = a.getAll(\"foo\"); // correct\nconst a2: Array<string | File | number> = a.getAll(\"foo\"); // incorrect\nconst a3: Array<string | Blob | File> = a.getAll(\"foo\"); // incorrect\na.getAll(23); // incorrect\n\n// set\na.set(\"foo\", \"bar\"); // correct\na.set(\"foo\", {}); // incorrect\na.set(2, \"bar\"); // incorrect\na.set(\"foo\", \"bar\", \"baz\"); // incorrect\na.set(\"bar\", new File([], \"q\")); // correct\na.set(\"bar\", new File([], \"q\"), \"x\"); // correct\na.set(\"bar\", new File([], \"q\"), 2); // incorrect\na.set(\"bar\", new Blob()); // correct\na.set(\"bar\", new Blob(), \"x\"); // correct\na.set(\"bar\", new Blob(), 2); // incorrect\n\n// append\na.append(\"foo\", \"bar\"); // correct\na.append(\"foo\", {}); // incorrect\na.append(2, \"bar\"); // incorrect\na.append(\"foo\", \"bar\", \"baz\"); // incorrect\na.append(\"foo\", \"bar\"); // correct\na.append(\"bar\", new File([], \"q\")); // correct\na.append(\"bar\", new File([], \"q\"), \"x\"); // correct\na.append(\"bar\", new File([], \"q\"), 2); // incorrect\na.append(\"bar\", new Blob()); // correct\na.append(\"bar\", new Blob(), \"x\"); // correct\na.append(\"bar\", new Blob(), 2); // incorrect\n\n// delete\na.delete(\"xx\"); // correct\na.delete(3); // incorrect\n\n// keys\nfor (let x: string of a.keys()) {\n} // correct\nfor (let x: number of a.keys()) {\n} // incorrect\n\n// values\nfor (let x: string | File of a.values()) {\n} // correct\nfor (let x: string | File | Blob of a.values()) {\n} // incorrect\n\n// entries\nfor (let [x, y]: [string, string | File] of a.entries()) {\n} // correct\nfor (let [x, y]: [string, string | File | Blob] of a.entries()) {\n} // incorrect\nfor (let [x, y]: [number, string] of a.entries()) {\n} // incorrect\nfor (let [x, y]: [string, number] of a.entries()) {\n} // incorrect\nfor (let [x, y]: [number, number] of a.entries()) {\n} // incorrect");
}
#[test]
fn test_mutation_observer_js_format_1_9321a21d() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parsers(vec!["flow"])
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\n// constructor\nfunction callback(arr: Array<MutationRecord>, observer: MutationObserver): void {\n  return;\n}\nconst o: MutationObserver = new MutationObserver(callback); // correct\nnew MutationObserver((arr: Array<MutationRecord>) => true); // correct\nnew MutationObserver(() => {}); // correct\nnew MutationObserver(); // incorrect\nnew MutationObserver(42); // incorrect\nnew MutationObserver((n: number) => {}); // incorrect\n\n// observe\nconst div = document.createElement('div');\no.observe(div, { attributes: true, attributeFilter: ['style'] }); // correct\no.observe(div, { characterData: true, invalid: true }); // correct\no.observe(); // incorrect\no.observe('invalid'); // incorrect\no.observe(div); // incorrect\no.observe(div, {}); // incorrect\no.observe(div, { subtree: true }); // incorrect\no.observe(div, { attributes: true, attributeFilter: true }); // incorrect\n\n// takeRecords\no.takeRecords(); // correct\n\n// disconnect\no.disconnect(); // correct") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\n// constructor\nfunction callback(\n  arr: Array<MutationRecord>,\n  observer: MutationObserver,\n): void {\n  return;\n}\nconst o: MutationObserver = new MutationObserver(callback); // correct\nnew MutationObserver((arr: Array<MutationRecord>) => true); // correct\nnew MutationObserver(() => {}); // correct\nnew MutationObserver(); // incorrect\nnew MutationObserver(42); // incorrect\nnew MutationObserver((n: number) => {}); // incorrect\n\n// observe\nconst div = document.createElement(\"div\");\no.observe(div, { attributes: true, attributeFilter: [\"style\"] }); // correct\no.observe(div, { characterData: true, invalid: true }); // correct\no.observe(); // incorrect\no.observe(\"invalid\"); // incorrect\no.observe(div); // incorrect\no.observe(div, {}); // incorrect\no.observe(div, { subtree: true }); // incorrect\no.observe(div, { attributes: true, attributeFilter: true }); // incorrect\n\n// takeRecords\no.takeRecords(); // correct\n\n// disconnect\no.disconnect(); // correct");
}
