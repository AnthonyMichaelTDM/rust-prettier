#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[test]
fn test_typeof_js_format_1_afaba623() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("/**\n * @flow\n */\n\n//////////////////////////////////\n// == typeof <<class value>> == //\n//////////////////////////////////\n\n// MyClass1 is a runtime value, a constructor function\n//\nclass MyClass1 {\n  getNumber(): number { return 42; }\n}\n\n// a is an instance of MyClass1 - in runtime terms,\n// an object produced by the MyClass1 constructor\n// function.\n//\nvar a: MyClass1 = new MyClass1();\n\n// Following tests are errors which conflate the type\n// of the class value itself with the type of its\n// instances.\n\n// Aside: it's worth staring at the following (correct)\n// type annotations until they make sense:\n//\n//    MyClass1 : Class<MyClass1>\n//    (new MyClass1()) : MyClass1\n//\n// The first says that the MyClass1 value (constructor\n// function) has type Class<MyClass1> - the type of\n// functions which produce instances of MyClass1 when\n// called as a constructor.\n//\n// The second says that objects produced by the MyClass1\n// constructor function have type MyClass1 - the type of\n// instances of MyClass1.\n\n// Error: assign the actual MyClass1 value to a  variable\n// whose annotated type is of instances of MyClass1.\n//\nvar b: MyClass1 = MyClass1;\n\nclass MyClass2 {\n  getNumber1(): number { return 42; }\n}\n\n// The opposite error: assign an *instance* of MyClass2\n// to a variable whose annotated type is the type of\n// the class value (constructor function) MyClass2 itself.\n//\nvar c: typeof MyClass2 = new MyClass2();\n\n//////////////////////////////////////\n// == typeof <<non-class value>> == //\n//////////////////////////////////////\n\nvar numValue:number = 42;\nvar d: typeof numValue = 100;\nvar e: typeof numValue = 'asdf'; // Error: string ~> number\n\n/////////////////////////////////\n// == typeof <<type-alias>> == //\n/////////////////////////////////\n\ntype numberAlias = number;\n\n// This is an error because typeof takes a value, not\n// a type, as an argument. However, the current error\n// is suboptimal - just 'cannot resolve name'. TODO.\n//\nvar f: typeof numberAlias = 42; // Error: 'typeof <<type-alias>>' makes no sense...\n\n/**\n * Use of a non-class/non-function value in type annotation.\n * These provoke a specific error, not just the generic\n * \"type is incompatible\"\n */\n\n var Map = { \"A\": \"this is A\", \"B\": \"this is B\", \"C\": \"this is C\" };\n var keys: $Keys<Map> = \"A\";  // Error: ineligible value used in type anno") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/**\n * @flow\n */\n\n//////////////////////////////////\n// == typeof <<class value>> == //\n//////////////////////////////////\n\n// MyClass1 is a runtime value, a constructor function\n//\nclass MyClass1 {\n  getNumber(): number {\n    return 42;\n  }\n}\n\n// a is an instance of MyClass1 - in runtime terms,\n// an object produced by the MyClass1 constructor\n// function.\n//\nvar a: MyClass1 = new MyClass1();\n\n// Following tests are errors which conflate the type\n// of the class value itself with the type of its\n// instances.\n\n// Aside: it's worth staring at the following (correct)\n// type annotations until they make sense:\n//\n//    MyClass1 : Class<MyClass1>\n//    (new MyClass1()) : MyClass1\n//\n// The first says that the MyClass1 value (constructor\n// function) has type Class<MyClass1> - the type of\n// functions which produce instances of MyClass1 when\n// called as a constructor.\n//\n// The second says that objects produced by the MyClass1\n// constructor function have type MyClass1 - the type of\n// instances of MyClass1.\n\n// Error: assign the actual MyClass1 value to a  variable\n// whose annotated type is of instances of MyClass1.\n//\nvar b: MyClass1 = MyClass1;\n\nclass MyClass2 {\n  getNumber1(): number {\n    return 42;\n  }\n}\n\n// The opposite error: assign an *instance* of MyClass2\n// to a variable whose annotated type is the type of\n// the class value (constructor function) MyClass2 itself.\n//\nvar c: typeof MyClass2 = new MyClass2();\n\n//////////////////////////////////////\n// == typeof <<non-class value>> == //\n//////////////////////////////////////\n\nvar numValue: number = 42;\nvar d: typeof numValue = 100;\nvar e: typeof numValue = \"asdf\"; // Error: string ~> number\n\n/////////////////////////////////\n// == typeof <<type-alias>> == //\n/////////////////////////////////\n\ntype numberAlias = number;\n\n// This is an error because typeof takes a value, not\n// a type, as an argument. However, the current error\n// is suboptimal - just 'cannot resolve name'. TODO.\n//\nvar f: typeof numberAlias = 42; // Error: 'typeof <<type-alias>>' makes no sense...\n\n/**\n * Use of a non-class/non-function value in type annotation.\n * These provoke a specific error, not just the generic\n * \"type is incompatible\"\n */\n\nvar Map = { A: \"this is A\", B: \"this is B\", C: \"this is C\" };\nvar keys: $Keys<Map> = \"A\"; // Error: ineligible value used in type anno");
}
