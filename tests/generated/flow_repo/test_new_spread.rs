#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[test]
fn test_type_js_format_1_6c6caced() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("declare class T {}\ndeclare var x: T;\n\ndeclare class U {}\ndeclare var y: U;\n\ndeclare var nil: {||};\n\n// inexact: \\`p\\` may be non-own\ntype O1 = {...{p:T}};\ndeclare var o1: O1;\n(o1: {p?:T}); // ok\n(o1: {p:T}); // error: o1.p is optional\n({}: O1); // ok\n({p:x}: O1); // ok\n({p:y}: O1); // error: y ~> T\n({p:x,q:y}: O1); // ok\n\n// inexact: optional \\`p\\`, if own, must be \\`T\\`\ntype O2 = {...{p?:T}};\ndeclare var o2: O2;\n(o2: {p?:T}); // ok\n(o2: {p:T}); // error: o2.p is optional\n({}: O2); // ok\n({p:x}: O2); // ok\n({p:y}: O2); // error: y ~> T\n({p:x,q:y}: O2); // ok\n\n// can't make exact from inexact (TODO: force EvalT eagerly)\ntype O3 = {|...{p:T}|}; ({p:x}: O3); // error: spread result is not exact\n\n// exact\ntype O4 = {...{|p:T|}};\ndeclare var o4: O4;\n(o4: {p:T}); // ok\n(o4: {|p:T|}); // error: not exact\n({}: O4); // error: property \\`p\\` not found\n({p:x}: O4); // ok\n({p:y}: O4); // error: y ~> T\n({p:x,q:y}: O4); // ok\n\n// can make exact from exact\ntype O5 = {|...{|p:T|}|};\ndeclare var o5: O5;\n(o5: {p:T}); // ok\n(o5: {|p:T|}); // ok\n(nil: O5); // error: property \\`p\\` not found\n({p:x}: O5); // ok\n({p:y}: O5); // error: y ~> T\n({p:x,q:y}: O5); // error: additional property \\`q\\` found\n\n// inexact p + exact p\ntype O6 = {...{p:T},...{|p:U|}};\ndeclare var o6: O6;\n(o6: {p:U}); // ok\n({}: O6); // error: property \\`p\\` not found\n({p:x}: O6); // error: x ~> U\n({p:y}: O6); // ok\n({p:y,q:x}: O6); // ok\n\n// inexact p + exact p ~> exact (TODO: force EvalT eagerly)\ntype O7 = {|...{p:T},...{|p:U|}|}; ({p:y}: O7);// error: spread result is not exact\n\n// exact p + inexact p\ntype O8 = {...{|p:T|},...{p:U}};\ndeclare var o8: O8;\n(o8: {p:T|U}); // ok\n(o8.p: T); // error: U ~> T\n(o8.p: U); // error: T ~> U\n\n// inexact p + exact q\ntype O9 = {...{p:T},...{|q:U|}};\ndeclare var o9: O9;\n(o9: {p?:T,q:U});\n(o9.p: T); // error: o9.p is optional\n(o9.q: U); // ok\n\n// exact p + inexact q\ntype O10 = {...{|p:T|},...{q:U}};\ndeclare var o10: O10;\n(o10: {p:mixed, q?: U}); // ok\n\n// inexact p + inexact q\ntype O11 = {...{p:T},...{q:U}};\ndeclare var o11: O11;\n(o11: {p:mixed, q: mixed}); // ok\n\n// exact + exact\ntype O12 = {...{|p:T|},...{|q:U|}};\ndeclare var o12: O12;\n(o12: {p:T,q:U}); // ok\n\n// inline properties are exact\ntype O13 = {...{p:T},p:U};\ndeclare var o13: O13;\n(o13: {p:U});") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "declare class T {}\ndeclare var x: T;\n\ndeclare class U {}\ndeclare var y: U;\n\ndeclare var nil: {||};\n\n// inexact: \\`p\\` may be non-own\ntype O1 = { ...{ p: T } };\ndeclare var o1: O1;\n(o1: { p?: T }); // ok\n(o1: { p: T }); // error: o1.p is optional\n({}: O1); // ok\n({ p: x }: O1); // ok\n({ p: y }: O1); // error: y ~> T\n({ p: x, q: y }: O1); // ok\n\n// inexact: optional \\`p\\`, if own, must be \\`T\\`\ntype O2 = { ...{ p?: T } };\ndeclare var o2: O2;\n(o2: { p?: T }); // ok\n(o2: { p: T }); // error: o2.p is optional\n({}: O2); // ok\n({ p: x }: O2); // ok\n({ p: y }: O2); // error: y ~> T\n({ p: x, q: y }: O2); // ok\n\n// can't make exact from inexact (TODO: force EvalT eagerly)\ntype O3 = {| ...{ p: T } |};\n({ p: x }: O3); // error: spread result is not exact\n\n// exact\ntype O4 = { ...{| p: T |} };\ndeclare var o4: O4;\n(o4: { p: T }); // ok\n(o4: {| p: T |}); // error: not exact\n({}: O4); // error: property \\`p\\` not found\n({ p: x }: O4); // ok\n({ p: y }: O4); // error: y ~> T\n({ p: x, q: y }: O4); // ok\n\n// can make exact from exact\ntype O5 = {| ...{| p: T |} |};\ndeclare var o5: O5;\n(o5: { p: T }); // ok\n(o5: {| p: T |}); // ok\n(nil: O5); // error: property \\`p\\` not found\n({ p: x }: O5); // ok\n({ p: y }: O5); // error: y ~> T\n({ p: x, q: y }: O5); // error: additional property \\`q\\` found\n\n// inexact p + exact p\ntype O6 = { ...{ p: T }, ...{| p: U |} };\ndeclare var o6: O6;\n(o6: { p: U }); // ok\n({}: O6); // error: property \\`p\\` not found\n({ p: x }: O6); // error: x ~> U\n({ p: y }: O6); // ok\n({ p: y, q: x }: O6); // ok\n\n// inexact p + exact p ~> exact (TODO: force EvalT eagerly)\ntype O7 = {| ...{ p: T }, ...{| p: U |} |};\n({ p: y }: O7); // error: spread result is not exact\n\n// exact p + inexact p\ntype O8 = { ...{| p: T |}, ...{ p: U } };\ndeclare var o8: O8;\n(o8: { p: T | U }); // ok\n(o8.p: T); // error: U ~> T\n(o8.p: U); // error: T ~> U\n\n// inexact p + exact q\ntype O9 = { ...{ p: T }, ...{| q: U |} };\ndeclare var o9: O9;\n(o9: { p?: T, q: U });\n(o9.p: T); // error: o9.p is optional\n(o9.q: U); // ok\n\n// exact p + inexact q\ntype O10 = { ...{| p: T |}, ...{ q: U } };\ndeclare var o10: O10;\n(o10: { p: mixed, q?: U }); // ok\n\n// inexact p + inexact q\ntype O11 = { ...{ p: T }, ...{ q: U } };\ndeclare var o11: O11;\n(o11: { p: mixed, q: mixed }); // ok\n\n// exact + exact\ntype O12 = { ...{| p: T |}, ...{| q: U |} };\ndeclare var o12: O12;\n(o12: { p: T, q: U }); // ok\n\n// inline properties are exact\ntype O13 = { ...{ p: T }, p: U };\ndeclare var o13: O13;\n(o13: { p: U });");
}
#[test]
fn test_type_any_js_format_1_113ffa25() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("type O1 = {...any};\nvar o1: O1 = (0: mixed); // ok\n(o1: empty); // ok\n\ntype O2 = {...Object};\nvar o2: O2 = (0: mixed); // ok\n(o2: empty); // ok\n\ndeclare var Base: any;\ndeclare class Derived extends Base {}\ntype O3 = {...Derived};\nvar o3: O3 = (0: mixed); // ok\n(o3: empty) // ok") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "type O1 = { ...any };\nvar o1: O1 = (0: mixed); // ok\n(o1: empty); // ok\n\ntype O2 = { ...Object };\nvar o2: O2 = (0: mixed); // ok\n(o2: empty); // ok\n\ndeclare var Base: any;\ndeclare class Derived extends Base {}\ntype O3 = { ...Derived };\nvar o3: O3 = (0: mixed); // ok\n(o3: empty); // ok");
}
#[test]
fn test_type_contra_js_format_1_7edf3c88() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("declare class T {};\n\ntype O1 = {...{-p:T}};\ndeclare var o1: O1;\n(o1: {p?:mixed}); // ok\n(o1: {p?:T}); // error: unknown ~> T\n(o1.p: T); // errors: undefined ~> T, unknown ~> T\n\ntype O2 = {...{-[string]:T}};\ndeclare var o2: O2;\n(o2: {[string]:mixed}); // ok\n(o2: {[string]:T}); // error: unknown ~> T\n(o2.p: T); // errors: unknown ~> T") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "declare class T {}\n\ntype O1 = { ...{ -p: T } };\ndeclare var o1: O1;\n(o1: { p?: mixed }); // ok\n(o1: { p?: T }); // error: unknown ~> T\n(o1.p: T); // errors: undefined ~> T, unknown ~> T\n\ntype O2 = { ...{ -[string]: T } };\ndeclare var o2: O2;\n(o2: { [string]: mixed }); // ok\n(o2: { [string]: T }); // error: unknown ~> T\n(o2.p: T); // errors: unknown ~> T");
}
#[test]
fn test_type_dict_js_format_1_e70c6b65() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("declare class T {}\ndeclare class U {}\n\ndeclare var o1: {...{[string]:T},...{p:U}};\n(o1: {p?:T|U,[string]:T}); // ok\n\ndeclare var o2: {...{p:T},...{[string]:U}};\n(o2: {p?:T|U,[string]:U}); // ok\n\ndeclare var o3: {...{[string]:T},...{[string]:U}};\n(o3: {[string]:T|U}); // ok\n\ndeclare var o4: {...{|[string]:T|},...{p:U}};\n(o4: {p?:T|U,[string]:T}); // ok\n\ndeclare var o5: {...{|p:T|},...{[string]:U}};\n(o5: {p:T|U,[string]:U}); // ok\n\ndeclare var o6: {...{|[string]:T|},...{[string]:U}};\n(o6: {[string]:T|U}); // ok\n\ndeclare var o7: {...{[string]:T},...{|p:U|}};\n(o7: {p:U,[string]:T}); // ok\n\ndeclare var o8: {...{p:T},...{|[string]:U|}};\n(o8: {p?:T|U,[string]:U}); // ok\n\ndeclare var o9: {...{[string]:T},...{|[string]:U|}};\n(o9: {[string]:T|U}); // ok\n\ndeclare var o10: {...{|[string]:T|},...{|p:U|}};\n(o10: {|p:U,[string]:T|}); // ok\n\ndeclare var o11: {...{|p :T|},...{|[string]:U|}};\n(o11: {|p:T|U,[string]:U|}); // ok\n\ndeclare var o12: {...{|[string]:T|},...{|[string]:U|}};\n(o12: {|[string]:T|U|}); // ok") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "declare class T {}\ndeclare class U {}\n\ndeclare var o1: { ...{ [string]: T }, ...{ p: U } };\n(o1: { p?: T | U, [string]: T }); // ok\n\ndeclare var o2: { ...{ p: T }, ...{ [string]: U } };\n(o2: { p?: T | U, [string]: U }); // ok\n\ndeclare var o3: { ...{ [string]: T }, ...{ [string]: U } };\n(o3: { [string]: T | U }); // ok\n\ndeclare var o4: { ...{| [string]: T |}, ...{ p: U } };\n(o4: { p?: T | U, [string]: T }); // ok\n\ndeclare var o5: { ...{| p: T |}, ...{ [string]: U } };\n(o5: { p: T | U, [string]: U }); // ok\n\ndeclare var o6: { ...{| [string]: T |}, ...{ [string]: U } };\n(o6: { [string]: T | U }); // ok\n\ndeclare var o7: { ...{ [string]: T }, ...{| p: U |} };\n(o7: { p: U, [string]: T }); // ok\n\ndeclare var o8: { ...{ p: T }, ...{| [string]: U |} };\n(o8: { p?: T | U, [string]: U }); // ok\n\ndeclare var o9: { ...{ [string]: T }, ...{| [string]: U |} };\n(o9: { [string]: T | U }); // ok\n\ndeclare var o10: { ...{| [string]: T |}, ...{| p: U |} };\n(o10: {| p: U, [string]: T |}); // ok\n\ndeclare var o11: { ...{| p: T |}, ...{| [string]: U |} };\n(o11: {| p: T | U, [string]: U |}); // ok\n\ndeclare var o12: { ...{| [string]: T |}, ...{| [string]: U |} };\n(o12: {| [string]: T | U |}); // ok");
}
#[test]
fn test_type_generic_js_format_1_2a31e8ef() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("declare function spread<A,B>(a: A, b: B): {...A, ...B};\n(spread({p:0},{q:0}): {|+p:number,+q:number|}); // ok\n(spread({p:0},{q:0}): {|+p:empty,+q:empty|}); // number ~> empty (x2)") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "declare function spread<A, B>(a: A, b: B): { ...A, ...B };\n(spread({ p: 0 }, { q: 0 }): {| +p: number, +q: number |}); // ok\n(spread({ p: 0 }, { q: 0 }): {| +p: empty, +q: empty |}); // number ~> empty (x2)");
}
#[test]
fn test_type_instance_js_format_1_ee03f34d() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("class A {+p: string|number}\nclass B extends A {p: number}\n\ntype O1 = {...B};\ndeclare var o1: O1;\n(o1: {p?:number}); // ok\n\ndeclare class C {[string]:number}\ntype O2 = {...C};\ndeclare var o2: O2;\n(o2: {[string]:number}); // ok") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "class A {\n  +p: string | number;\n}\nclass B extends A {\n  p: number;\n}\n\ntype O1 = { ...B };\ndeclare var o1: O1;\n(o1: { p?: number }); // ok\n\ndeclare class C {\n  [string]: number;\n}\ntype O2 = { ...C };\ndeclare var o2: O2;\n(o2: { [string]: number }); // ok");
}
#[test]
fn test_type_intersection_js_format_1_8df5c040() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("declare class T {}\ndeclare class U {}\n\ndeclare class A {}\ndeclare class B extends A {}\n\ntype O1 = {...{p:T}&{q:U}};\ndeclare var o1: O1;\n(o1: {p?:T,q?:U}); // ok\n\ntype O2 = {...{p:A}&{p:B}};\ndeclare var o2: O2;\n(o2: {p?:B}); // ok\n({p: new B}: O2); // ok\n({p: new A}: O2); // error: A ~> B\n\ntype O3 = {...{p:A}&{[string]:B}};\ndeclare var o3: O3;\n(o3: {p:B,[string]:B});// ok: A&B = B\n(o3.q: B); // ok\n\ntype O4 = {...{[string]:A}&{p:B}};\ndeclare var o4: O4;\n(o4: {p:B,[string]:A}); // ok: A&B = B\n\ntype O5 = {...{[string]:A}&{[string]:B}};\ndeclare var o5: O5;\n(o5: {[string]:B}); // ok: A&B = B") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "declare class T {}\ndeclare class U {}\n\ndeclare class A {}\ndeclare class B extends A {}\n\ntype O1 = { ...{ p: T } & { q: U } };\ndeclare var o1: O1;\n(o1: { p?: T, q?: U }); // ok\n\ntype O2 = { ...{ p: A } & { p: B } };\ndeclare var o2: O2;\n(o2: { p?: B }); // ok\n({ p: new B() }: O2); // ok\n({ p: new A() }: O2); // error: A ~> B\n\ntype O3 = { ...{ p: A } & { [string]: B } };\ndeclare var o3: O3;\n(o3: { p: B, [string]: B }); // ok: A&B = B\n(o3.q: B); // ok\n\ntype O4 = { ...{ [string]: A } & { p: B } };\ndeclare var o4: O4;\n(o4: { p: B, [string]: A }); // ok: A&B = B\n\ntype O5 = { ...{ [string]: A } & { [string]: B } };\ndeclare var o5: O5;\n(o5: { [string]: B }); // ok: A&B = B");
}
#[test]
fn test_type_intersection_optional_js_format_1_4b524f2b() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("declare class T {}\ndeclare class U {}\n\ndeclare var o1: {...{p:T}&{p:U}};\n(o1: {p?:T&U}); // ok\n\ndeclare var o2: {...{p?:T}&{p:U}};\n(o2: {p?:T&U}); // ok\n\ndeclare var o3: {...{p:T}&{p?:U}};\n(o3: {p?:T&U}); // ok\n\ndeclare var o4: {...{p?:T}&{p?:U}};\n(o4: {p?:T&U}); // ok\n\ndeclare var o5: {...{|p:T|}&{p:U}};\n(o5: {p:T&U}); // ok\n\ndeclare var o6: {...{|p?:T|}&{p:U}};\n(o6: {p:T&U}); // ok\n\ndeclare var o7: {...{|p:T|}&{p?:U}};\n(o7: {p:T&U}); // ok\n\ndeclare var o8: {...{|p?:T|}&{p?:U}};\n(o8: {p?:T&U}); // ok\n\ndeclare var o9: {...{p:T}&{|p:U|}};\n(o9: {p:T&U}); // ok\n\ndeclare var o10: {...{p?:T}&{|p:U|}};\n(o10: {p:T&U}); // ok\n\ndeclare var o11: {...{p:T}&{|p?:U|}};\n(o11: {p:T&U}); // ok\n\ndeclare var o12: {...{p?:T}&{|p?:U|}};\n(o12: {p?:T&U}); // ok\n\ndeclare var o13: {...{|p:T|}&{|p:U|}};\n(o13: {|p:T&U|}); // ok\n\ndeclare var o14: {...{|p?:T|}&{|p:U|}};\n(o14: {|p:T&U|}); // ok\n\ndeclare var o15: {...{|p:T|}&{|p?:U|}};\n(o15: {|p:T&U|}); // ok\n\ndeclare var o16: {...{|p?:T|}&{|p?:U|}};\n(o16: {|p?:T&U|}); // ok\n\ndeclare var o17: {...{p:T}&{q:U}};\n(o17: {p?:T,q?:U}); // ok\n\ndeclare var o18: {...{p?:T}&{q:U}};\n(o18: {p?:T,q?:U}); // ok\n\ndeclare var o19: {...{p:T}&{q?:U}};\n(o19: {p?:T,q?:U}); // ok\n\ndeclare var o20: {...{p?:T}&{q?:U}};\n(o20: {p?:T,q?:U}); // ok\n\ndeclare var o21: {...{|p:T|}&{q:U}};\n(o21: {p:T,q?:U}); // ok") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "declare class T {}\ndeclare class U {}\n\ndeclare var o1: { ...{ p: T } & { p: U } };\n(o1: { p?: T & U }); // ok\n\ndeclare var o2: { ...{ p?: T } & { p: U } };\n(o2: { p?: T & U }); // ok\n\ndeclare var o3: { ...{ p: T } & { p?: U } };\n(o3: { p?: T & U }); // ok\n\ndeclare var o4: { ...{ p?: T } & { p?: U } };\n(o4: { p?: T & U }); // ok\n\ndeclare var o5: { ...{| p: T |} & { p: U } };\n(o5: { p: T & U }); // ok\n\ndeclare var o6: { ...{| p?: T |} & { p: U } };\n(o6: { p: T & U }); // ok\n\ndeclare var o7: { ...{| p: T |} & { p?: U } };\n(o7: { p: T & U }); // ok\n\ndeclare var o8: { ...{| p?: T |} & { p?: U } };\n(o8: { p?: T & U }); // ok\n\ndeclare var o9: { ...{ p: T } & {| p: U |} };\n(o9: { p: T & U }); // ok\n\ndeclare var o10: { ...{ p?: T } & {| p: U |} };\n(o10: { p: T & U }); // ok\n\ndeclare var o11: { ...{ p: T } & {| p?: U |} };\n(o11: { p: T & U }); // ok\n\ndeclare var o12: { ...{ p?: T } & {| p?: U |} };\n(o12: { p?: T & U }); // ok\n\ndeclare var o13: { ...{| p: T |} & {| p: U |} };\n(o13: {| p: T & U |}); // ok\n\ndeclare var o14: { ...{| p?: T |} & {| p: U |} };\n(o14: {| p: T & U |}); // ok\n\ndeclare var o15: { ...{| p: T |} & {| p?: U |} };\n(o15: {| p: T & U |}); // ok\n\ndeclare var o16: { ...{| p?: T |} & {| p?: U |} };\n(o16: {| p?: T & U |}); // ok\n\ndeclare var o17: { ...{ p: T } & { q: U } };\n(o17: { p?: T, q?: U }); // ok\n\ndeclare var o18: { ...{ p?: T } & { q: U } };\n(o18: { p?: T, q?: U }); // ok\n\ndeclare var o19: { ...{ p: T } & { q?: U } };\n(o19: { p?: T, q?: U }); // ok\n\ndeclare var o20: { ...{ p?: T } & { q?: U } };\n(o20: { p?: T, q?: U }); // ok\n\ndeclare var o21: { ...{| p: T |} & { q: U } };\n(o21: { p: T, q?: U }); // ok");
}
#[test]
fn test_type_optional_js_format_1_46ba2d0a() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("declare class T {}\ndeclare class U {}\n\ndeclare var a: {...{ p :T },...{ p :U }}; (a: { p?:T|U });\ndeclare var b: {...{ p?:T },...{ p :U }}; (b: { p?:T|U });\ndeclare var c: {...{ p :T },...{ p?:U }}; (c: { p?:T|U });\ndeclare var d: {...{ p?:T },...{ p?:U }}; (d: { p?:T|U });\n\ndeclare var e: {...{|p :T|},...{ p :U }}; (e: { p :T|U });\ndeclare var f: {...{|p?:T|},...{ p :U }}; (f: { p?:T|U });\ndeclare var g: {...{|p :T|},...{ p?:U }}; (g: { p :T|U });\ndeclare var h: {...{|p?:T|},...{ p?:U }}; (h: { p?:T|U });\n\ndeclare var i: {...{ p :T },...{|p :U|}}; (i: { p :  U });\ndeclare var j: {...{ p?:T },...{|p :U|}}; (j: { p :  U });\ndeclare var k: {...{ p :T },...{|p?:U|}}; (k: { p?:T|U });\ndeclare var l: {...{ p?:T },...{|p?:U|}}; (l: { p?:T|U });\n\ndeclare var m: {...{|p :T|},...{|p :U|}}; (m: {|p :  U|});\ndeclare var n: {...{|p?:T|},...{|p :U|}}; (n: {|p :  U|});\ndeclare var o: {...{|p :T|},...{|p?:U|}}; (o: {|p :T|U|});\ndeclare var p: {...{|p?:T|},...{|p?:U|}}; (p: {|p?:T|U|});") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "declare class T {}\ndeclare class U {}\n\ndeclare var a: { ...{ p: T }, ...{ p: U } };\n(a: { p?: T | U });\ndeclare var b: { ...{ p?: T }, ...{ p: U } };\n(b: { p?: T | U });\ndeclare var c: { ...{ p: T }, ...{ p?: U } };\n(c: { p?: T | U });\ndeclare var d: { ...{ p?: T }, ...{ p?: U } };\n(d: { p?: T | U });\n\ndeclare var e: { ...{| p: T |}, ...{ p: U } };\n(e: { p: T | U });\ndeclare var f: { ...{| p?: T |}, ...{ p: U } };\n(f: { p?: T | U });\ndeclare var g: { ...{| p: T |}, ...{ p?: U } };\n(g: { p: T | U });\ndeclare var h: { ...{| p?: T |}, ...{ p?: U } };\n(h: { p?: T | U });\n\ndeclare var i: { ...{ p: T }, ...{| p: U |} };\n(i: { p: U });\ndeclare var j: { ...{ p?: T }, ...{| p: U |} };\n(j: { p: U });\ndeclare var k: { ...{ p: T }, ...{| p?: U |} };\n(k: { p?: T | U });\ndeclare var l: { ...{ p?: T }, ...{| p?: U |} };\n(l: { p?: T | U });\n\ndeclare var m: { ...{| p: T |}, ...{| p: U |} };\n(m: {| p: U |});\ndeclare var n: { ...{| p?: T |}, ...{| p: U |} };\n(n: {| p: U |});\ndeclare var o: { ...{| p: T |}, ...{| p?: U |} };\n(o: {| p: T | U |});\ndeclare var p: { ...{| p?: T |}, ...{| p?: U |} };\n(p: {| p?: T | U |});");
}
#[test]
fn test_type_union_js_format_1_bfc35db1() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("declare class T {}\ndeclare var x: T;\n\ndeclare class U {}\ndeclare var y: U;\n\ntype O1 = {...{p:T}|{q:U}};\ndeclare var o1: O1;\n(o1: {p?:T}|{q?:U}); // ok") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "declare class T {}\ndeclare var x: T;\n\ndeclare class U {}\ndeclare var y: U;\n\ntype O1 = { ...{ p: T } | { q: U } };\ndeclare var o1: O1;\n(o1: { p?: T } | { q?: U }); // ok");
}
