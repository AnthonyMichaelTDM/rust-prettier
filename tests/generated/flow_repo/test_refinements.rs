use pretty_assertions::assert_eq;
#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[allow(dead_code)]
static INFINITY: usize = usize::MAX;
#[test]
fn test_assignment_js_format_1_a5a07298() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nfunction foo(x : ?number) {\n  var y;\n  if (y = x) {\n    var z = y * 1000;\n  }\n}\n\ntype Bar = {\n  parent: ?Bar;\n  doStuff: () => void\n}\n\nfunction bar0(x : Bar) {\n  while (x = x.parent) { // can't assign x to ?Bar\n    x.doStuff();\n  }\n}\n\nfunction bar1(x : ?Bar) {\n  while (x = x.parent) { // x.parent might be null\n    x.doStuff();\n  }\n}\n\nfunction bar2(x : Bar) {\n  var y = x;\n  while (y = y.parent) {\n    y.doStuff();\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nfunction foo(x: ?number) {\n  var y;\n  if ((y = x)) {\n    var z = y * 1000;\n  }\n}\n\ntype Bar = {\n  parent: ?Bar,\n  doStuff: () => void,\n};\n\nfunction bar0(x: Bar) {\n  while ((x = x.parent)) {\n    // can't assign x to ?Bar\n    x.doStuff();\n  }\n}\n\nfunction bar1(x: ?Bar) {\n  while ((x = x.parent)) {\n    // x.parent might be null\n    x.doStuff();\n  }\n}\n\nfunction bar2(x: Bar) {\n  var y = x;\n  while ((y = y.parent)) {\n    y.doStuff();\n  }\n}");
}
#[test]
fn test_ast_node_js_format_1_49adaedc() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("type Node1 = {\n  kind: 'Node1',\n  prop1?: string\n};\n\ntype Node2 = {\n  kind: 'Node2',\n  prop2?: string\n}\n\nexport type ASTNode = Node1 | Node2;") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "type Node1 = {\n  kind: \"Node1\",\n  prop1?: string,\n};\n\ntype Node2 = {\n  kind: \"Node2\",\n  prop2?: string,\n};\n\nexport type ASTNode = Node1 | Node2;");
}
#[test]
fn test_bool_js_format_1_234bd8e0() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nfunction foo(x: ?bool) {\n  if (x === false) {\n    return;\n  }\n\n  if (x === true) {\n    return;\n  }\n\n  x[0]; // error on null and undefined\n}\n\nfunction bar(x: ?bool) {\n  if (x !== true) {\n    if (x !== false) {\n      x[0]; // error on null and undefined\n    }\n  }\n}\n\nfunction baz(x: ?bool) {\n  if (100 * false) {\n    return;\n  }\n  if (false * 100) {\n    return;\n  }\n}\n\nlet tests = [\n  function(x: { done: true, result: string } | { done: false }) {\n    if (x.done === true) {\n      return x.result;\n    }\n    return x.result; // error\n  },\n\n  function(x: { done: true, result: string } | { done: false }) {\n    if (true === x.done) {\n      return x.result;\n    }\n    return x.result; // error\n  },\n];") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nfunction foo(x: ?boolean) {\n  if (x === false) {\n    return;\n  }\n\n  if (x === true) {\n    return;\n  }\n\n  x[0]; // error on null and undefined\n}\n\nfunction bar(x: ?boolean) {\n  if (x !== true) {\n    if (x !== false) {\n      x[0]; // error on null and undefined\n    }\n  }\n}\n\nfunction baz(x: ?boolean) {\n  if (100 * false) {\n    return;\n  }\n  if (false * 100) {\n    return;\n  }\n}\n\nlet tests = [\n  function (x: { done: true, result: string } | { done: false }) {\n    if (x.done === true) {\n      return x.result;\n    }\n    return x.result; // error\n  },\n\n  function (x: { done: true, result: string } | { done: false }) {\n    if (true === x.done) {\n      return x.result;\n    }\n    return x.result; // error\n  },\n];");
}
#[test]
fn test_computed_string_literal_js_format_1_27493f19() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\ntype A = {\n  'b_c': ?string\n};\n\nfunction stuff(str: string) {}\n\nfunction testProperty(a: A) {\n  if (a.b_c) {\n    stuff(a.b_c)\n  }\n}\n\nfunction testLiteralProperty(a: A) {\n  if (a['b_c']) {\n    stuff(a['b_c'])\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "// @flow\n\ntype A = {\n  b_c: ?string,\n};\n\nfunction stuff(str: string) {}\n\nfunction testProperty(a: A) {\n  if (a.b_c) {\n    stuff(a.b_c);\n  }\n}\n\nfunction testLiteralProperty(a: A) {\n  if (a[\"b_c\"]) {\n    stuff(a[\"b_c\"]);\n  }\n}");
}
#[test]
fn test_cond_prop_js_format_1_24b46ef2() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\ntype Type = Name | ListType | NonNullType;\ntype Name = {kind: 'Name', value: string, type: void };\ntype ListType = {kind: 'ListType', type: Type};\ntype NonNullType = {kind: 'NonNullType', type: Name | ListType | BadType};\ntype BadType = {};\n\nfunction getTypeASTName(typeAST: Type): string {\n  if (!typeAST.type) throw new Error('Must be wrapping type'); // OK\n  return getTypeASTName(typeAST.type); // error, BadType not a subtype of Type\n}\n\nlet tests = [\n  function(x: { done: true, result: string } | { done: false }) {\n    if (x.done) {\n      return x.result;\n    }\n    return x.result; // error\n  },\n\n  function(x: { done: true, result: string } | { foo: string }) {\n    if (x.done) {\n      return x.result; // error, consider { foo: \"herp\", done: \"derp\" }\n    }\n    return x.result; // error\n  },\n\n  function() {\n    type T\n      = { foo: Object, bar: string }\n      | { baz: string, quux: string }\n\n    function testAlwaysTruthyProp(t: T) {\n      if (t.foo) {\n        (t.bar: string); // error, consider { baz: \"x\", quux: \"y\", foo: \"boom\" }\n      } else {\n        (t.quux: string); // ok. since foo is an object (always truthy), the\n                          // else case completely rules out the first branch of\n                          // the union.\n      }\n    }\n\n    function testSometimesTruthyProp(t: T) {\n      if (t.bar) {\n        (t.foo: Object); // error, consider { baz: \"x\", quux: \"y\", bar: \"boom\" }\n      } else {\n        (t.quux: string); // error, consider { foo: {}, bar: \"\" }\n      }\n    }\n  },\n]") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\ntype Type = Name | ListType | NonNullType;\ntype Name = { kind: \"Name\", value: string, type: void };\ntype ListType = { kind: \"ListType\", type: Type };\ntype NonNullType = { kind: \"NonNullType\", type: Name | ListType | BadType };\ntype BadType = {};\n\nfunction getTypeASTName(typeAST: Type): string {\n  if (!typeAST.type) throw new Error(\"Must be wrapping type\"); // OK\n  return getTypeASTName(typeAST.type); // error, BadType not a subtype of Type\n}\n\nlet tests = [\n  function (x: { done: true, result: string } | { done: false }) {\n    if (x.done) {\n      return x.result;\n    }\n    return x.result; // error\n  },\n\n  function (x: { done: true, result: string } | { foo: string }) {\n    if (x.done) {\n      return x.result; // error, consider { foo: \"herp\", done: \"derp\" }\n    }\n    return x.result; // error\n  },\n\n  function () {\n    type T = { foo: Object, bar: string } | { baz: string, quux: string };\n\n    function testAlwaysTruthyProp(t: T) {\n      if (t.foo) {\n        (t.bar: string); // error, consider { baz: \"x\", quux: \"y\", foo: \"boom\" }\n      } else {\n        (t.quux: string); // ok. since foo is an object (always truthy), the\n        // else case completely rules out the first branch of\n        // the union.\n      }\n    }\n\n    function testSometimesTruthyProp(t: T) {\n      if (t.bar) {\n        (t.foo: Object); // error, consider { baz: \"x\", quux: \"y\", bar: \"boom\" }\n      } else {\n        (t.quux: string); // error, consider { foo: {}, bar: \"\" }\n      }\n    }\n  },\n];");
}
#[test]
fn test_constants_js_format_1_bfcd9389() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nexport const SUCCESS: 'SUCCESS' = 'SUCCESS';\nexport const ERROR: 'ERROR' = 'ERROR';") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nexport const SUCCESS: \"SUCCESS\" = \"SUCCESS\";\nexport const ERROR: \"ERROR\" = \"ERROR\";");
}
#[test]
fn test_eq_js_format_1_07b2d2ba() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nlet tests = [\n  function(x: string, y: number) {\n    if (x == y) {} // error, string & number are not comparable (unsafe casting)\n    if (x === y) {} // no error, to match \\`let z = (x === y)\\` which is allowed\n  },\n\n  function(x: string) {\n    if (x == undefined) {} // ok\n    if (x == void 0) {} // ok\n  },\n\n  function(x: string) {\n    if (x == null) {} // ok\n  },\n\n  function(x: { y: 'foo' } | { y: 'bar' }) {\n    if (x.y == 123) {} // error\n    if (x.y === 123) {} // ok\n  },\n]") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nlet tests = [\n  function (x: string, y: number) {\n    if (x == y) {\n    } // error, string & number are not comparable (unsafe casting)\n    if (x === y) {\n    } // no error, to match \\`let z = (x === y)\\` which is allowed\n  },\n\n  function (x: string) {\n    if (x == undefined) {\n    } // ok\n    if (x == void 0) {\n    } // ok\n  },\n\n  function (x: string) {\n    if (x == null) {\n    } // ok\n  },\n\n  function (x: { y: \"foo\" } | { y: \"bar\" }) {\n    if (x.y == 123) {\n    } // error\n    if (x.y === 123) {\n    } // ok\n  },\n];");
}
#[test]
fn test_exists_js_format_1_ecd71477() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("declare class Foo {\n  foo: string;\n}\n\nfunction foo0(x: ?string): string {\n  return x && x || \"\";\n}\n\nfunction foo1(x: ?Foo): string {\n  return x && x.foo || \"\";\n}\n\nfunction foo2(x: ?Class<Foo>): string {\n  return x && new x().foo || \"\";\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "declare class Foo {\n  foo: string;\n}\n\nfunction foo0(x: ?string): string {\n  return (x && x) || \"\";\n}\n\nfunction foo1(x: ?Foo): string {\n  return (x && x.foo) || \"\";\n}\n\nfunction foo2(x: ?Class<Foo>): string {\n  return (x && new x().foo) || \"\";\n}");
}
#[test]
fn test_func_call_js_format_1_5110a56d() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\nlet tests = [\n  function(x: { y?: string }, z: () => string) {\n    if (x.y) {\n      // make sure we visit the AST in the correct order. if we visit z() before\n      // x.y, then the function call will invalidate the refinement of x.y\n      // incorrectly.\n      x.y.indexOf(z()); // no error\n    }\n  },\n];") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "// @flow\n\nlet tests = [\n  function (x: { y?: string }, z: () => string) {\n    if (x.y) {\n      // make sure we visit the AST in the correct order. if we visit z() before\n      // x.y, then the function call will invalidate the refinement of x.y\n      // incorrectly.\n      x.y.indexOf(z()); // no error\n    }\n  },\n];");
}
#[test]
fn test_has_own_property_js_format_1_26f6ea1b() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nfunction foo(x:{y?:() => void}) {\n  x.y(); // error: could be undefined\n  if (x.hasOwnProperty('y')) {\n    x.y(); // error: still could be undefined\n  }\n  if (x.hasOwnProperty('z')) {\n    x.z(); // error: unreachable, but we don't help you here\n  }\n}\n\nfunction bar(x:Object) {\n  x.y(); // treated as \\`any\\`, so allowed\n  if (x.hasOwnProperty('y')) {\n    x.y(); // still treated as \\`any\\`, so allowed\n  }\n  if (x.hasOwnProperty('z')) {\n    x.z(); // also treated as \\`any\\`, so allowed\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nfunction foo(x: { y?: () => void }) {\n  x.y(); // error: could be undefined\n  if (x.hasOwnProperty(\"y\")) {\n    x.y(); // error: still could be undefined\n  }\n  if (x.hasOwnProperty(\"z\")) {\n    x.z(); // error: unreachable, but we don't help you here\n  }\n}\n\nfunction bar(x: Object) {\n  x.y(); // treated as \\`any\\`, so allowed\n  if (x.hasOwnProperty(\"y\")) {\n    x.y(); // still treated as \\`any\\`, so allowed\n  }\n  if (x.hasOwnProperty(\"z\")) {\n    x.z(); // also treated as \\`any\\`, so allowed\n  }\n}");
}
#[test]
fn test_heap_defassign_js_format_1_55136232() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\ntype Obj = { p: number | string }\n\nfunction f () {}\n\nfunction def_assign_function_havoc(obj: Obj) {\n    obj.p = 10;                 // (obj.p : number)\n    f();                        // clears refi\n    var x: number = obj.p;      // error, obj.p : number | string\n}\n\nfunction def_assign_setprop_havoc(obj: Obj, obj2: Obj) {\n    obj.p = 10;                 // (obj.p : number)\n    obj2.p = 'hey';             // clears refi\n    var x: number = obj.p;      // error, obj.p : number | string\n}\n\nfunction def_assign_index_havoc(obj: Obj, obj2: Obj) {\n    obj.p = 10;                 // (obj.p : number)\n    obj2['p'] = 'hey';          // clears refi\n    var x: number = obj.p;      // error, obj.p : number | string\n}\n\nfunction def_assign_within_if(b: boolean, obj: Obj) {\n    if (b) {\n        obj.p = 10;             // (obj.p : number)\n        var x: number = obj.p   // ok by def assign\n    }\n    var y: number = obj.p;      // error, obj.p : number | string\n}\n\nfunction def_assign_within_while(b: boolean, obj: Obj) {\n    while (b) {\n        obj.p = 10;             // (obj.p : number)\n        var x: number = obj.p   // ok by def assign\n    }\n    var y: number = obj.p;      // error, obj.p : number | string\n}\n\nfunction def_assign_within_do(b: boolean, obj: Obj) {\n    do {\n        obj.p = 10;             // (obj.p : number)\n        var x: number = obj.p   // ok by def assign\n    } while (b);\n    var y: number = obj.p;      // no error, loop runs at least once\n}\n\nfunction def_assign_within_try(b: boolean, obj: Obj) {\n    obj.p = 10;                 // (obj.p : number)\n    try {\n        f();                    // clears refi and might throw\n        obj.p = 'hey';\n    } catch (e) {\n        f();                    // clears refi and might throw\n        obj.p = 'hey';\n    } finally {\n        // NOTE: the values understood to flow to obj.p at this point\n        // include the number 42 written downstream;\n        // so if we did y:string, we would get at least a spurious error\n        // (among other reasonable errors caused by values written upstream)\n        var y: number = obj.p;  // error, string ~/~ number\n        obj.p = 42;\n    }\n    var z:string = obj.p;       // error, number ~/~ string\n}\n\nfunction def_assign_within_for(b: boolean, obj: Obj) {\n    for (; b; ) {\n        obj.p = 10;             // (obj.p : number)\n        var x: number = obj.p   // ok by def assign\n    }\n    var z: number = obj.p;      // error, (number | string) ~/~ number\n}\n\n// --- name-sensitive havoc ---\n\ntype Obj2 = { q: number | string }\n\nfunction def_assign_setprop_nohavoc(obj: Obj, obj2: Obj2) {\n    obj.p = 10;                 // (obj.p : number)\n    obj2.q = 'hey';             // doesn't clear refi of .p\n    var x: number = obj.p;      // still ok\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "// @flow\n\ntype Obj = { p: number | string };\n\nfunction f() {}\n\nfunction def_assign_function_havoc(obj: Obj) {\n  obj.p = 10; // (obj.p : number)\n  f(); // clears refi\n  var x: number = obj.p; // error, obj.p : number | string\n}\n\nfunction def_assign_setprop_havoc(obj: Obj, obj2: Obj) {\n  obj.p = 10; // (obj.p : number)\n  obj2.p = \"hey\"; // clears refi\n  var x: number = obj.p; // error, obj.p : number | string\n}\n\nfunction def_assign_index_havoc(obj: Obj, obj2: Obj) {\n  obj.p = 10; // (obj.p : number)\n  obj2[\"p\"] = \"hey\"; // clears refi\n  var x: number = obj.p; // error, obj.p : number | string\n}\n\nfunction def_assign_within_if(b: boolean, obj: Obj) {\n  if (b) {\n    obj.p = 10; // (obj.p : number)\n    var x: number = obj.p; // ok by def assign\n  }\n  var y: number = obj.p; // error, obj.p : number | string\n}\n\nfunction def_assign_within_while(b: boolean, obj: Obj) {\n  while (b) {\n    obj.p = 10; // (obj.p : number)\n    var x: number = obj.p; // ok by def assign\n  }\n  var y: number = obj.p; // error, obj.p : number | string\n}\n\nfunction def_assign_within_do(b: boolean, obj: Obj) {\n  do {\n    obj.p = 10; // (obj.p : number)\n    var x: number = obj.p; // ok by def assign\n  } while (b);\n  var y: number = obj.p; // no error, loop runs at least once\n}\n\nfunction def_assign_within_try(b: boolean, obj: Obj) {\n  obj.p = 10; // (obj.p : number)\n  try {\n    f(); // clears refi and might throw\n    obj.p = \"hey\";\n  } catch (e) {\n    f(); // clears refi and might throw\n    obj.p = \"hey\";\n  } finally {\n    // NOTE: the values understood to flow to obj.p at this point\n    // include the number 42 written downstream;\n    // so if we did y:string, we would get at least a spurious error\n    // (among other reasonable errors caused by values written upstream)\n    var y: number = obj.p; // error, string ~/~ number\n    obj.p = 42;\n  }\n  var z: string = obj.p; // error, number ~/~ string\n}\n\nfunction def_assign_within_for(b: boolean, obj: Obj) {\n  for (; b; ) {\n    obj.p = 10; // (obj.p : number)\n    var x: number = obj.p; // ok by def assign\n  }\n  var z: number = obj.p; // error, (number | string) ~/~ number\n}\n\n// --- name-sensitive havoc ---\n\ntype Obj2 = { q: number | string };\n\nfunction def_assign_setprop_nohavoc(obj: Obj, obj2: Obj2) {\n  obj.p = 10; // (obj.p : number)\n  obj2.q = \"hey\"; // doesn't clear refi of .p\n  var x: number = obj.p; // still ok\n}");
}
#[test]
fn test_lib_js_format_1_d1bc9a75() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer
        .format("/* @flow */\n\ndeclare var BAZ: {stuff?: (x: number) => void} | void;");
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq!(
        formatted,
        "/* @flow */\n\ndeclare var BAZ: { stuff?: (x: number) => void } | void;"
    );
}
#[test]
fn test_missing_property_cond_js_format_1_0849b1ba() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\nfunction foo1(o: { x: number }) {\n  if (o.p1) { // OK, this is an idiomatic way of testing property existence\n    o.x;\n  }\n}\n\nfunction foo2(o: { x: number }) {\n  if (o.p2) { // OK\n    o.p2.x; // error, since o.p2's type is unknown (e.g., could be \\`number\\`)\n  }\n}\n\nfunction foo3(o: { x: number }) {\n  o.p3.x; // usual error outside conditional\n}\n\nfunction foo4(o: $Exact<{ x: number }>) {\n  if (o.p4) { // OK\n    o.p4.x; // currently OK, should be unreachable\n  } else {\n    o.p4.x; // error\n  }\n}\n\nfunction foo5() {\n  const o = { };\n  _foo5();\n  if (o.p) { o.p(); }\n  function _foo5() {\n    o.p = function() { }\n  }\n}\n\nfunction foo6(o: mixed) {\n  if (o.bar) {} // error, any lookup on mixed is unsafe\n}\n\nfunction foo7(o: mixed) {\n  if (typeof o.bar === 'string') {} // error\n  if (o && typeof o.bar === 'string') {} // ok\n  if (o != null && typeof o.bar === 'string') {} // ok\n  if (o !== null && o !== undefined && typeof o.bar === 'string') {} // ok\n}\n\nfunction foo8(o: { p: mixed }) {\n  if (o.p && o.p.q) {} // this is ok because o.p is truthy, so o.p.q is safe\n  if (o.p && o.p.q && o.p.q.r) {}\n}\n\ntype Foo9Expected = {\n  foo: string,\n}\n\nfunction foo9() {\n  const actual = {};\n  if (actual.foo === undefined) {\n    actual.foo = 'foo';\n  }\n  (actual: Foo9Expected);\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "// @flow\n\nfunction foo1(o: { x: number }) {\n  if (o.p1) {\n    // OK, this is an idiomatic way of testing property existence\n    o.x;\n  }\n}\n\nfunction foo2(o: { x: number }) {\n  if (o.p2) {\n    // OK\n    o.p2.x; // error, since o.p2's type is unknown (e.g., could be \\`number\\`)\n  }\n}\n\nfunction foo3(o: { x: number }) {\n  o.p3.x; // usual error outside conditional\n}\n\nfunction foo4(o: $Exact<{ x: number }>) {\n  if (o.p4) {\n    // OK\n    o.p4.x; // currently OK, should be unreachable\n  } else {\n    o.p4.x; // error\n  }\n}\n\nfunction foo5() {\n  const o = {};\n  _foo5();\n  if (o.p) {\n    o.p();\n  }\n  function _foo5() {\n    o.p = function () {};\n  }\n}\n\nfunction foo6(o: mixed) {\n  if (o.bar) {\n  } // error, any lookup on mixed is unsafe\n}\n\nfunction foo7(o: mixed) {\n  if (typeof o.bar === \"string\") {\n  } // error\n  if (o && typeof o.bar === \"string\") {\n  } // ok\n  if (o != null && typeof o.bar === \"string\") {\n  } // ok\n  if (o !== null && o !== undefined && typeof o.bar === \"string\") {\n  } // ok\n}\n\nfunction foo8(o: { p: mixed }) {\n  if (o.p && o.p.q) {\n  } // this is ok because o.p is truthy, so o.p.q is safe\n  if (o.p && o.p.q && o.p.q.r) {\n  }\n}\n\ntype Foo9Expected = {\n  foo: string,\n};\n\nfunction foo9() {\n  const actual = {};\n  if (actual.foo === undefined) {\n    actual.foo = \"foo\";\n  }\n  (actual: Foo9Expected);\n}");
}
#[test]
fn test_mixed_js_format_1_c042295e() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nfunction takesNumber(x: number) {}\nfunction takesString(x: string) {}\n\nfunction num(x: mixed) {\n  if (typeof x === \"number\") {\n    takesString(x); // error\n    (!x: false); // error: we don't know the truthiness of x\n  }\n  if (typeof x === \"number\" && x) {\n    (!x: false); // ok\n  }\n  if (x && typeof x === \"number\") {\n    (!x: false); // ok\n  }\n}\n\nfunction str(x: mixed) {\n  if (typeof x === \"string\") {\n    takesNumber(x); // error\n    (!x: false); // error: we don't know the truthiness of x\n  }\n  if (typeof x === \"string\" && x) {\n    (!x: false); // ok\n  }\n  if (x && typeof x === \"string\") {\n    (!x: false); // ok\n  }\n}\n\nfunction bool(x: mixed) {\n  if (typeof x === \"boolean\") {\n    takesString(x); // error\n    (x: true); // error: we don't know the truthiness of x\n  }\n  if (typeof x === \"boolean\" && x) {\n    (x: true); // ok\n  }\n  if (x && typeof x === \"boolean\") {\n    (x: true); // ok\n  }\n}\n\nfunction fun(x: mixed) {\n  if (typeof x === \"function\") {\n    takesString(x); // error\n  }\n}\n\nfunction obj0(x: mixed) {\n  if (typeof x === \"object\") {\n    takesString(x); // error\n  }\n}\n\nfunction obj1(x: mixed) {\n  if (Array.isArray(x)) {\n    takesString(x); // error\n  }\n}\n\nfunction undef(x: mixed) {\n  if (typeof x === \"undefined\") {\n    takesString(x); // error\n  }\n}\n\nfunction null_(x: mixed) {\n  if (x === null) {\n    takesString(x); // error\n  }\n}\n\nfunction maybe(x: mixed) {\n  if (x == null) {\n    takesString(x); // error\n  }\n}\n\nfunction true_(x: mixed) {\n  if (x === true) {\n    takesString(x); // error\n  }\n}\n\nfunction false_(x: mixed) {\n  if (x === false) {\n    takesString(x); // error\n  }\n}\n\nfunction obj2(x: mixed) {\n  if (typeof x === \"object\") {\n    (x: { [key: string]: mixed } | null);\n    if (x !== null) {\n      (x['foo']: string); // error, mixed\n    }\n  }\n}\n\nfunction obj2(x: mixed) {\n  if (typeof x === \"object\" && x) {\n    (x: Object);\n  }\n  if (x && typeof x === \"object\") {\n    (x: Object);\n  }\n  if (x != null && typeof x === \"object\") {\n    (x: Object);\n  }\n  if (x !== null && typeof x === \"object\") {\n    (x: Object);\n  }\n}\n\nfunction arr0(x: mixed) {\n  if (Array.isArray(x)) {\n    takesString(x[0]); // error\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nfunction takesNumber(x: number) {}\nfunction takesString(x: string) {}\n\nfunction num(x: mixed) {\n  if (typeof x === \"number\") {\n    takesString(x); // error\n    (!x: false); // error: we don't know the truthiness of x\n  }\n  if (typeof x === \"number\" && x) {\n    (!x: false); // ok\n  }\n  if (x && typeof x === \"number\") {\n    (!x: false); // ok\n  }\n}\n\nfunction str(x: mixed) {\n  if (typeof x === \"string\") {\n    takesNumber(x); // error\n    (!x: false); // error: we don't know the truthiness of x\n  }\n  if (typeof x === \"string\" && x) {\n    (!x: false); // ok\n  }\n  if (x && typeof x === \"string\") {\n    (!x: false); // ok\n  }\n}\n\nfunction bool(x: mixed) {\n  if (typeof x === \"boolean\") {\n    takesString(x); // error\n    (x: true); // error: we don't know the truthiness of x\n  }\n  if (typeof x === \"boolean\" && x) {\n    (x: true); // ok\n  }\n  if (x && typeof x === \"boolean\") {\n    (x: true); // ok\n  }\n}\n\nfunction fun(x: mixed) {\n  if (typeof x === \"function\") {\n    takesString(x); // error\n  }\n}\n\nfunction obj0(x: mixed) {\n  if (typeof x === \"object\") {\n    takesString(x); // error\n  }\n}\n\nfunction obj1(x: mixed) {\n  if (Array.isArray(x)) {\n    takesString(x); // error\n  }\n}\n\nfunction undef(x: mixed) {\n  if (typeof x === \"undefined\") {\n    takesString(x); // error\n  }\n}\n\nfunction null_(x: mixed) {\n  if (x === null) {\n    takesString(x); // error\n  }\n}\n\nfunction maybe(x: mixed) {\n  if (x == null) {\n    takesString(x); // error\n  }\n}\n\nfunction true_(x: mixed) {\n  if (x === true) {\n    takesString(x); // error\n  }\n}\n\nfunction false_(x: mixed) {\n  if (x === false) {\n    takesString(x); // error\n  }\n}\n\nfunction obj2(x: mixed) {\n  if (typeof x === \"object\") {\n    (x: { [key: string]: mixed } | null);\n    if (x !== null) {\n      (x[\"foo\"]: string); // error, mixed\n    }\n  }\n}\n\nfunction obj2(x: mixed) {\n  if (typeof x === \"object\" && x) {\n    (x: Object);\n  }\n  if (x && typeof x === \"object\") {\n    (x: Object);\n  }\n  if (x != null && typeof x === \"object\") {\n    (x: Object);\n  }\n  if (x !== null && typeof x === \"object\") {\n    (x: Object);\n  }\n}\n\nfunction arr0(x: mixed) {\n  if (Array.isArray(x)) {\n    takesString(x[0]); // error\n  }\n}");
}
#[test]
fn test_node_1_js_format_1_9c5d76b5() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer.format("module.exports = 'Node1';");
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq!(formatted, "module.exports = \"Node1\";");
}
#[test]
fn test_not_js_format_1_d8e36fb3() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nfunction foo(x: ?bool) {\n  if (!x) {\n    x++; // should error for null, void and bool (false)\n  }\n}\n\nfunction bar(x: ?number) {\n  if (!x) {\n    x[0]; // should error for null, void and number (0)\n  }\n}\n\nfunction baz (x: ?number) {\n  if (x === null || x === undefined) {\n    return;\n  }\n\n  if (!x) {\n    x[0]; // should error for number (0)\n  }\n}\n\nclass TestClass {}\n\nlet tests = [\n  function() {\n    var y = true;\n    while (y) {\n      y = !y;\n    }\n  },\n  function(x: Function) {\n    (!x: false); // ok, functions are always truthy\n  },\n  function(x: Object) {\n    (!x: false); // ok, objects are always truthy\n  },\n  function(x: string) {\n    (!x: false); // error, strings are not always truthy\n  },\n  function(x: number) {\n    (!x: false); // error, numbers are not always truthy\n  },\n  function(x: boolean) {\n    (!x: false); // error, bools are not always truthy\n  },\n  function(x: TestClass) {\n    (!x: false); // ok, classes are always truthy\n  },\n];") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nfunction foo(x: ?boolean) {\n  if (!x) {\n    x++; // should error for null, void and bool (false)\n  }\n}\n\nfunction bar(x: ?number) {\n  if (!x) {\n    x[0]; // should error for null, void and number (0)\n  }\n}\n\nfunction baz(x: ?number) {\n  if (x === null || x === undefined) {\n    return;\n  }\n\n  if (!x) {\n    x[0]; // should error for number (0)\n  }\n}\n\nclass TestClass {}\n\nlet tests = [\n  function () {\n    var y = true;\n    while (y) {\n      y = !y;\n    }\n  },\n  function (x: Function) {\n    (!x: false); // ok, functions are always truthy\n  },\n  function (x: Object) {\n    (!x: false); // ok, objects are always truthy\n  },\n  function (x: string) {\n    (!x: false); // error, strings are not always truthy\n  },\n  function (x: number) {\n    (!x: false); // error, numbers are not always truthy\n  },\n  function (x: boolean) {\n    (!x: false); // error, bools are not always truthy\n  },\n  function (x: TestClass) {\n    (!x: false); // ok, classes are always truthy\n  },\n];");
}
#[test]
fn test_null_js_format_1_bbb1468b() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nfunction null_bogus_comparison() {\n  if (100 * null) {\n    return;\n  }\n  if (null * 100) {\n    return;\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nfunction null_bogus_comparison() {\n  if (100 * null) {\n    return;\n  }\n  if (null * 100) {\n    return;\n  }\n}");
}
#[test]
fn test_number_js_format_1_935717db() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\ntype Mode = 0 | 1 | 2;\n\nlet tests = [\n  function(x: number) {\n    if (x === 0) {\n      (x: void); // error\n    }\n    (x: 0); // error\n  },\n\n  function(x: number) {\n    if (x !== 0) {\n      (x: 0); // error\n    }\n    (x: void); // error\n  },\n\n  function(x: 1): 0 {\n    if (x === 0) {\n      return x; // unreachable, no error\n    }\n    return 0;\n  },\n\n  function(x: 0): number {\n    if (x === 1) {\n      return x;\n    }\n    return x;\n  },\n\n  function(x: 0) {\n    if (x !== 1) {\n      (x: 0);\n    }\n    (x: 0);\n  },\n\n  function(x: 0): number {\n    if (x === 0) {\n      return x;\n    }\n    return x;\n  },\n\n  function(x: 0 | 1) {\n    if (x === 0) {\n      (x: 0);\n      (x: void); // error\n    }\n    if (x === 1) {\n      (x: 1);\n      (x: void); // error\n    }\n  },\n\n  function(x: { foo: number }): 0 {\n    if (x.foo === 0) {\n      return x.foo;\n    }\n    return x.foo; // error\n  },\n\n  function(\n    x: { kind: 0, foo: number } | { kind: 1, bar: number }\n  ): number {\n    if (x.kind === 0) {\n      return x.foo;\n    } else {\n      return x.bar;\n    }\n  },\n\n  function(num: number, obj: { foo: number }) {\n    if (num === obj.bar) { // ok, typos allowed in conditionals\n    }\n  },\n\n  function(num: number, obj: {[key: string]: number}) {\n    if (num === obj.bar) { // ok\n    }\n  },\n\n  function(n: number): Mode {\n    if (n !== 0 && n !== 1 && n !== 2) {\n      throw new Error(\"Wrong number passed\");\n    }\n    return n;\n  },\n\n  function(s: number): ?Mode {\n    if (s === 0) {\n      return s;\n    } else if (s === 3) {\n      return s; // error\n    }\n  },\n\n  function(mode: Mode) {\n    switch (mode) {\n      case 0:\n        (mode: 0);\n        break;\n\n      case 1:\n      case 2:\n        (mode: 1 | 2);\n        break;\n    }\n  },\n\n  function(x: number): 0 {\n    if (x) {\n      return x; // error\n    } else {\n      return x; // no error, inferred to be 0\n    }\n  },\n];") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "// @flow\n\ntype Mode = 0 | 1 | 2;\n\nlet tests = [\n  function (x: number) {\n    if (x === 0) {\n      (x: void); // error\n    }\n    (x: 0); // error\n  },\n\n  function (x: number) {\n    if (x !== 0) {\n      (x: 0); // error\n    }\n    (x: void); // error\n  },\n\n  function (x: 1): 0 {\n    if (x === 0) {\n      return x; // unreachable, no error\n    }\n    return 0;\n  },\n\n  function (x: 0): number {\n    if (x === 1) {\n      return x;\n    }\n    return x;\n  },\n\n  function (x: 0) {\n    if (x !== 1) {\n      (x: 0);\n    }\n    (x: 0);\n  },\n\n  function (x: 0): number {\n    if (x === 0) {\n      return x;\n    }\n    return x;\n  },\n\n  function (x: 0 | 1) {\n    if (x === 0) {\n      (x: 0);\n      (x: void); // error\n    }\n    if (x === 1) {\n      (x: 1);\n      (x: void); // error\n    }\n  },\n\n  function (x: { foo: number }): 0 {\n    if (x.foo === 0) {\n      return x.foo;\n    }\n    return x.foo; // error\n  },\n\n  function (x: { kind: 0, foo: number } | { kind: 1, bar: number }): number {\n    if (x.kind === 0) {\n      return x.foo;\n    } else {\n      return x.bar;\n    }\n  },\n\n  function (num: number, obj: { foo: number }) {\n    if (num === obj.bar) {\n      // ok, typos allowed in conditionals\n    }\n  },\n\n  function (num: number, obj: { [key: string]: number }) {\n    if (num === obj.bar) {\n      // ok\n    }\n  },\n\n  function (n: number): Mode {\n    if (n !== 0 && n !== 1 && n !== 2) {\n      throw new Error(\"Wrong number passed\");\n    }\n    return n;\n  },\n\n  function (s: number): ?Mode {\n    if (s === 0) {\n      return s;\n    } else if (s === 3) {\n      return s; // error\n    }\n  },\n\n  function (mode: Mode) {\n    switch (mode) {\n      case 0:\n        (mode: 0);\n        break;\n\n      case 1:\n      case 2:\n        (mode: 1 | 2);\n        break;\n    }\n  },\n\n  function (x: number): 0 {\n    if (x) {\n      return x; // error\n    } else {\n      return x; // no error, inferred to be 0\n    }\n  },\n];");
}
#[test]
fn test_property_js_format_1_c2d1ce61() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nfunction a(x: {[key: string]: ?string}, y: string): string {\n  if (x[y]) {\n    return x[y];\n  }\n  return \"\";\n}\n\nfunction b(x: {y: {[key: string]: ?string}}, z: string): string {\n  if (x.y[z]) {\n    return x.y[z];\n  }\n  return \"\";\n}\n\nfunction c(x: {[key: string]: ?string}, y: {z: string}): string {\n  if (x[y.z]) {\n    return x[y.z];\n  }\n  return \"\";\n}\n\nfunction d(x: {y: {[key: string]: ?string}}, a: {b: string}): string {\n  if (x.y[a.b]) {\n    return x.y[a.b];\n  }\n  return \"\";\n}\n\nfunction a_array(x: Array<?string>, y: number): string {\n  if (x[y]) {\n    return x[y];\n  }\n  return \"\";\n}\n\nfunction b_array(x: {y: Array<?string>}, z: number): string {\n  if (x.y[z]) {\n    return x.y[z];\n  }\n  return \"\";\n}\n\nfunction c_array(x: Array<?string>, y: {z: number}): string {\n  if (x[y.z]) {\n    return x[y.z];\n  }\n  return \"\";\n}\n\nfunction d_array(x: {y: Array<?string>}, a: {b: number}): string {\n  if (x.y[a.b]) {\n    return x.y[a.b];\n  }\n  return \"\";\n}\n\nfunction e_array(x: Array<?string>): string {\n  if (x[0]) {\n    return x[0];\n  }\n  return \"\";\n}\n\n// --- name-sensitive havoc ---\n\nfunction c2(x: {[key: string]: ?string}, y: {z: string}): string {\n  if (x[y.z]) {\n    y.z = \"HEY\";\n    return x[y.z];  // error\n  }\n  return \"\";\n}\n\nfunction c3(x: {[key: string]: ?string}, y: {z: string, a: string}): string {\n  if (x[y.z]) {\n    y.a = \"HEY\";\n    return x[y.z];  // ok\n  }\n  return \"\";\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nfunction a(x: { [key: string]: ?string }, y: string): string {\n  if (x[y]) {\n    return x[y];\n  }\n  return \"\";\n}\n\nfunction b(x: { y: { [key: string]: ?string } }, z: string): string {\n  if (x.y[z]) {\n    return x.y[z];\n  }\n  return \"\";\n}\n\nfunction c(x: { [key: string]: ?string }, y: { z: string }): string {\n  if (x[y.z]) {\n    return x[y.z];\n  }\n  return \"\";\n}\n\nfunction d(x: { y: { [key: string]: ?string } }, a: { b: string }): string {\n  if (x.y[a.b]) {\n    return x.y[a.b];\n  }\n  return \"\";\n}\n\nfunction a_array(x: Array<?string>, y: number): string {\n  if (x[y]) {\n    return x[y];\n  }\n  return \"\";\n}\n\nfunction b_array(x: { y: Array<?string> }, z: number): string {\n  if (x.y[z]) {\n    return x.y[z];\n  }\n  return \"\";\n}\n\nfunction c_array(x: Array<?string>, y: { z: number }): string {\n  if (x[y.z]) {\n    return x[y.z];\n  }\n  return \"\";\n}\n\nfunction d_array(x: { y: Array<?string> }, a: { b: number }): string {\n  if (x.y[a.b]) {\n    return x.y[a.b];\n  }\n  return \"\";\n}\n\nfunction e_array(x: Array<?string>): string {\n  if (x[0]) {\n    return x[0];\n  }\n  return \"\";\n}\n\n// --- name-sensitive havoc ---\n\nfunction c2(x: { [key: string]: ?string }, y: { z: string }): string {\n  if (x[y.z]) {\n    y.z = \"HEY\";\n    return x[y.z]; // error\n  }\n  return \"\";\n}\n\nfunction c3(\n  x: { [key: string]: ?string },\n  y: { z: string, a: string },\n): string {\n  if (x[y.z]) {\n    y.a = \"HEY\";\n    return x[y.z]; // ok\n  }\n  return \"\";\n}");
}
#[test]
fn test_refinements_js_format_1_c3a157dd() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("function foo(b) {\n    var x = b? 0 : null;\n    while (typeof x == \"string\" || typeof x == \"number\") {\n        var y:string = x;\n        x = false;\n    }\n    var z:string = x;\n}\n\nfunction bar(b) {\n    var x = b? 0 : null;\n    do {\n        var y:string = x;\n        x = false;\n    } while (x === null);\n    var z:string = x;\n}\n\nfunction maybe_throw() { }\nfunction qux() {\n    var x = 0;\n    try {\n        maybe_throw();\n        x = \"hello\";\n    } catch (e) {\n        maybe_throw();\n        x = \"hello\";\n    } finally {\n        // NOTE: the values understood to flow to x at this point\n        // include the number 42 written downstream;\n        // so if we did y:string, we would get at least a spurious error\n        // (among other reasonable errors caused by values written upstream)\n        var y:number = x;\n        x = 42;\n    }\n    var z:string = x;\n}\n\nfunction corge(b) {\n    for (var x = b? 0 : null;\n         typeof x == \"string\" || typeof x == \"number\";\n         x = false) {\n        var y:string = x;\n    }\n    var z:string = x;\n}\n\nfunction waldo() {\n    var o = {};\n    var x = false;\n    for (x in o) {\n        x = 0; // commenting this out would propagate x:string downstream\n    }\n    var z:number = x;\n}\n\n// regression test: bring a global into scope by testing it.\n// this has no refinement consequences and is error-free.\n// the way we currently cache global lookups causes uneven\n// distribution of the global's entries at path merge time,\n// so we need to recognize that it's legit rather than an\n// internal error.\n//\nfunction global_in_conditional0(x: number) {\n    // merge_env\n    if (x != 0) {\n        if (BAZ) {\n        }\n    }\n}\n\nfunction global_in_conditional2(x: number) {\n    // copy_env\n    for (var i = 0; i < 100; i++) {\n        if (BAZ) {\n        }\n    }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "function foo(b) {\n  var x = b ? 0 : null;\n  while (typeof x == \"string\" || typeof x == \"number\") {\n    var y: string = x;\n    x = false;\n  }\n  var z: string = x;\n}\n\nfunction bar(b) {\n  var x = b ? 0 : null;\n  do {\n    var y: string = x;\n    x = false;\n  } while (x === null);\n  var z: string = x;\n}\n\nfunction maybe_throw() {}\nfunction qux() {\n  var x = 0;\n  try {\n    maybe_throw();\n    x = \"hello\";\n  } catch (e) {\n    maybe_throw();\n    x = \"hello\";\n  } finally {\n    // NOTE: the values understood to flow to x at this point\n    // include the number 42 written downstream;\n    // so if we did y:string, we would get at least a spurious error\n    // (among other reasonable errors caused by values written upstream)\n    var y: number = x;\n    x = 42;\n  }\n  var z: string = x;\n}\n\nfunction corge(b) {\n  for (\n    var x = b ? 0 : null;\n    typeof x == \"string\" || typeof x == \"number\";\n    x = false\n  ) {\n    var y: string = x;\n  }\n  var z: string = x;\n}\n\nfunction waldo() {\n  var o = {};\n  var x = false;\n  for (x in o) {\n    x = 0; // commenting this out would propagate x:string downstream\n  }\n  var z: number = x;\n}\n\n// regression test: bring a global into scope by testing it.\n// this has no refinement consequences and is error-free.\n// the way we currently cache global lookups causes uneven\n// distribution of the global's entries at path merge time,\n// so we need to recognize that it's legit rather than an\n// internal error.\n//\nfunction global_in_conditional0(x: number) {\n  // merge_env\n  if (x != 0) {\n    if (BAZ) {\n    }\n  }\n}\n\nfunction global_in_conditional2(x: number) {\n  // copy_env\n  for (var i = 0; i < 100; i++) {\n    if (BAZ) {\n    }\n  }\n}");
}
#[test]
fn test_string_js_format_1_28496ae0() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// @flow\n\ntype Mode = \"a\" | \"b\" | \"c\";\n\nlet tests = [\n  function(x: string) {\n    if (x === 'foo') {\n      (x: void); // error\n    }\n    (x: 'foo'); // error\n  },\n\n  function(x: string) {\n    if (x !== 'foo') {\n      (x: 'foo'); // error\n    }\n    (x: void); // error\n  },\n\n  function(x: 'bar'): 'foo' {\n    if (x === 'foo') {\n      return x; // unreachable, no error\n    }\n    return 'foo';\n  },\n\n  function(x: 'foo'): string {\n    if (x === 'bar') {\n      return x;\n    }\n    return x;\n  },\n\n  function(x: 'foo') {\n    if (x !== 'bar') {\n      (x: 'foo');\n    }\n    (x: 'foo');\n  },\n\n  function(x: 'foo'): string {\n    if (x === 'foo') {\n      return x;\n    }\n    return x;\n  },\n\n  function(x: 'foo' | 'bar') {\n    if (x === 'foo') {\n      (x: 'foo');\n      (x: void); // error\n    }\n    if (x === 'bar') {\n      (x: 'bar');\n      (x: void); // error\n    }\n  },\n\n  function(x: { foo: string }): 'foo' {\n    if (x.foo === 'foo') {\n      return x.foo;\n    }\n    return x.foo; // error\n  },\n\n  function(\n    x: { kind: 'foo', foo: string } | { kind: 'bar', bar: string }\n  ): string {\n    if (x.kind === 'foo') {\n      return x.foo;\n    } else {\n      return x.bar;\n    }\n  },\n\n  function(str: string, obj: { foo: string }) {\n    if (str === obj.bar) { // ok, typos allowed in conditionals\n    }\n  },\n\n  function(str: string, obj: {[key: string]: string}) {\n    if (str === obj.bar) { // ok\n    }\n  },\n\n  function(str: string): Mode {\n    var ch = str[0];\n    if (ch !== \"a\" && ch !== \"b\" && ch !== \"c\") {\n      throw new Error(\"Wrong string passed\");\n    }\n    return ch;\n  },\n\n  function(s: string): ?Mode {\n    if (s === \"a\") {\n      return s;\n    } else if (s === \"d\") {\n      return s; // error\n    }\n  },\n\n  function(mode: Mode) {\n    switch (mode) {\n      case \"a\":\n        (mode: \"a\");\n        break;\n\n      case \"b\":\n      case \"c\":\n        (mode: \"b\" | \"c\");\n        break;\n    }\n  },\n\n  function(x: string): \"\" {\n    if (x) {\n      return x; // error\n    } else {\n      return x; // no error, inferred to be \"\"\n    }\n  },\n\n  // Simple template literals are ok\n  function(x: string): 'foo' {\n    if (x === \\`foo\\`) {\n      return x;\n    }\n    if (\\`foo\\` === x) {\n      return x;\n    }\n    return 'foo';\n  },\n];") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "// @flow\n\ntype Mode = \"a\" | \"b\" | \"c\";\n\nlet tests = [\n  function (x: string) {\n    if (x === \"foo\") {\n      (x: void); // error\n    }\n    (x: \"foo\"); // error\n  },\n\n  function (x: string) {\n    if (x !== \"foo\") {\n      (x: \"foo\"); // error\n    }\n    (x: void); // error\n  },\n\n  function (x: \"bar\"): \"foo\" {\n    if (x === \"foo\") {\n      return x; // unreachable, no error\n    }\n    return \"foo\";\n  },\n\n  function (x: \"foo\"): string {\n    if (x === \"bar\") {\n      return x;\n    }\n    return x;\n  },\n\n  function (x: \"foo\") {\n    if (x !== \"bar\") {\n      (x: \"foo\");\n    }\n    (x: \"foo\");\n  },\n\n  function (x: \"foo\"): string {\n    if (x === \"foo\") {\n      return x;\n    }\n    return x;\n  },\n\n  function (x: \"foo\" | \"bar\") {\n    if (x === \"foo\") {\n      (x: \"foo\");\n      (x: void); // error\n    }\n    if (x === \"bar\") {\n      (x: \"bar\");\n      (x: void); // error\n    }\n  },\n\n  function (x: { foo: string }): \"foo\" {\n    if (x.foo === \"foo\") {\n      return x.foo;\n    }\n    return x.foo; // error\n  },\n\n  function (\n    x: { kind: \"foo\", foo: string } | { kind: \"bar\", bar: string },\n  ): string {\n    if (x.kind === \"foo\") {\n      return x.foo;\n    } else {\n      return x.bar;\n    }\n  },\n\n  function (str: string, obj: { foo: string }) {\n    if (str === obj.bar) {\n      // ok, typos allowed in conditionals\n    }\n  },\n\n  function (str: string, obj: { [key: string]: string }) {\n    if (str === obj.bar) {\n      // ok\n    }\n  },\n\n  function (str: string): Mode {\n    var ch = str[0];\n    if (ch !== \"a\" && ch !== \"b\" && ch !== \"c\") {\n      throw new Error(\"Wrong string passed\");\n    }\n    return ch;\n  },\n\n  function (s: string): ?Mode {\n    if (s === \"a\") {\n      return s;\n    } else if (s === \"d\") {\n      return s; // error\n    }\n  },\n\n  function (mode: Mode) {\n    switch (mode) {\n      case \"a\":\n        (mode: \"a\");\n        break;\n\n      case \"b\":\n      case \"c\":\n        (mode: \"b\" | \"c\");\n        break;\n    }\n  },\n\n  function (x: string): \"\" {\n    if (x) {\n      return x; // error\n    } else {\n      return x; // no error, inferred to be \"\"\n    }\n  },\n\n  // Simple template literals are ok\n  function (x: string): \"foo\" {\n    if (x === \\`foo\\`) {\n      return x;\n    }\n    if (\\`foo\\` === x) {\n      return x;\n    }\n    return \"foo\";\n  },\n];");
}
#[test]
fn test_super_member_js_format_1_f6be5f68() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nclass A {\n  prop: string;\n  method(): string {\n    return \"A\";\n  }\n}\n\nclass B {\n  test(): string {\n    if (super.prop) { // super.prop doesn't exist\n      return super.prop; // error, unknown type passed to string expected\n    }\n    return \"B\";\n  }\n}\n\nclass C extends A {\n  test(): string {\n    if (super.prop) {\n      return super.prop; // OK\n    }\n    return \"C\";\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nclass A {\n  prop: string;\n  method(): string {\n    return \"A\";\n  }\n}\n\nclass B {\n  test(): string {\n    if (super.prop) {\n      // super.prop doesn't exist\n      return super.prop; // error, unknown type passed to string expected\n    }\n    return \"B\";\n  }\n}\n\nclass C extends A {\n  test(): string {\n    if (super.prop) {\n      return super.prop; // OK\n    }\n    return \"C\";\n  }\n}");
}
#[test]
fn test_switch_js_format_1_4521bfcc() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nfunction foo(text: string | number): string {\n  switch (typeof text) {\n\u{3000}\u{3000}case 'string':\n\u{3000}\u{3000}\u{3000}return text;\n    case 'number':\n      return text; // error, should return string\n\u{3000}\u{3000}default:\n\u{3000}\u{3000}\u{3000}return 'wat';\n\u{3000}}\n}\n\nfunction bar(text: string | number): string {\n  switch (typeof text) {\n    case 'string':\n      return text[0];\n  \u{3000}default:\n      return (text++) + '';\n\u{3000}}\n}\n\nfunction baz1(text: string | number): string {\n  switch (typeof text) {\n    case 'number':\n    case 'string':\n      return text[0]; // error, [0] on number\n  \u{3000}default:\n      return 'wat';\n\u{3000}}\n}\n\nfunction baz2(text: string | number): string {\n  switch (typeof text) {\n    case 'string':\n    case 'number':\n      return text[0]; // error, [0] on number\n  \u{3000}default:\n      return 'wat';\n\u{3000}}\n}\n\nfunction corge(text: string | number | Array<string>): string {\n  switch (typeof text) {\n    case 'object':\n      return text[0];\n    case 'string':\n    case 'number':\n      // using ++ since it isn't valid on arrays or strings.\n      // should only error for string since Array was filtered out.\n      return (text++) + '';\n  \u{3000}default:\n      return 'wat';\n\u{3000}}\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nfunction foo(text: string | number): string {\n  switch (typeof text) {\n    case \"string\":\n      return text;\n    case \"number\":\n      return text; // error, should return string\n    default:\n      return \"wat\";\n  }\n}\n\nfunction bar(text: string | number): string {\n  switch (typeof text) {\n    case \"string\":\n      return text[0];\n    default:\n      return text++ + \"\";\n  }\n}\n\nfunction baz1(text: string | number): string {\n  switch (typeof text) {\n    case \"number\":\n    case \"string\":\n      return text[0]; // error, [0] on number\n    default:\n      return \"wat\";\n  }\n}\n\nfunction baz2(text: string | number): string {\n  switch (typeof text) {\n    case \"string\":\n    case \"number\":\n      return text[0]; // error, [0] on number\n    default:\n      return \"wat\";\n  }\n}\n\nfunction corge(text: string | number | Array<string>): string {\n  switch (typeof text) {\n    case \"object\":\n      return text[0];\n    case \"string\":\n    case \"number\":\n      // using ++ since it isn't valid on arrays or strings.\n      // should only error for string since Array was filtered out.\n      return text++ + \"\";\n    default:\n      return \"wat\";\n  }\n}");
}
#[test]
fn test_tagged_union_js_format_1_df7e2d12() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("// example 1\n\ntype Type = Name | ListType;\ntype Name = {kind: 'Name', value: string};\ntype ListType = {kind: 'ListType', name: string};\n\nfunction getTypeASTName(typeAST: Type): string {\n  if (typeAST.kind === 'Name') {\n    return typeAST.value; // OK, since typeAST: Name\n  } else {\n    return typeAST.name; // OK, since typeAST: ListType\n  }\n}\n\n// example 2\nimport type {ASTNode} from './ast_node';\nvar Node = require('./node1'); // Node = \"Node1\"\nfunction foo(x: ASTNode) {\n  if (x.kind === Node) {\n    return x.prop1.charAt(0); // typeAST: Node1, but x.prop1 may be undefined\n  }\n  return null;\n}\n\n// example 3\ntype Apple = { kind: 'Fruit', taste: 'Bad' }\ntype Orange = { kind: 'Fruit', taste: 'Good' }\ntype Broccoli = { kind: 'Veg', taste: 'Bad', raw: 'No' }\ntype Carrot = { kind: 'Veg', taste: 'Good', raw: 'Maybe' }\n\ntype Breakfast = Apple | Orange | Broccoli | Carrot\n\nfunction bar(x: Breakfast) {\n  if (x.kind === 'Fruit') { (x.taste: 'Good'); } // error, Apple.taste = Bad\n  else (x.raw: 'No'); // error, Carrot.raw = Maybe\n}\n\nfunction qux(x: Breakfast) {\n  if (x.taste === 'Good') {\n    (x.raw: 'Yes' | 'No'); // 2 errors:\n                           // Orange.raw doesn't exist\n                           // Carrot.raw is neither Yes nor No\n  }\n}\n\n// example 4\nfunction list(n) {\n  if (n > 0) return { kind: \"cons\", next: list(n-1) };\n  return { kind: \"nil\" };\n}\nfunction length(l) {\n  switch (l.kind) {\n  case \"cons\": return 1 + length(l.next);\n  default: return 0;\n  }\n}\nfunction check(n) {\n  if (n >= 0) return (n === (length(list(n))));\n  return true;\n}\n\n\n// example 5\nvar EnumKind = { A: 1, B: 2, C: 3};\ntype A = { kind: 1, A: number };\ntype B = { kind: 2, B: number };\ntype C = { kind: 3, C: number };\nfunction kind(x: A | B | C): number {\n  switch (x.kind) {\n  case EnumKind.A: return x.A;\n  case EnumKind.B: return x.B;\n  default: return x.A; // error, x: C and property A not found in type C\n  }\n}\nkind({ kind: EnumKind.A, A: 1 });\n\n// example 6\ntype Citizen = { citizen: true };\ntype NonCitizen = { citizen: false, nationality: string }\nfunction nationality(x: Citizen | NonCitizen) {\n  if (x.citizen) return \"Shire\"\n  else return x.nationality;\n}\n\nlet tests = [\n  // non-existent props\n  function test7(x: A) {\n    if (x.kindTypo === 1) { // typos are allowed to be tested\n      (x.kindTypo: string); // typos can't be used, though\n    }\n  },\n\n  // nested objects\n  function test8(x: {foo: {bar: 1}}) {\n    if (x.foo.bar === 1) {}\n    if (x.fooTypo.bar === 1) {} // error, fooTypo doesn't exist\n  },\n\n  // invalid RHS\n  function(x: A) {\n    if (x.kind === (null).toString()) {} // error, method on null\n    if ({kind: 1}.kind === (null).toString()) {} // error, method on null\n  },\n\n  // non-objects on LHS\n  function(\n    x: Array<string>, y: string, z: number, q: boolean,\n    r: Object, s: Function, t: () => void\n  ) {\n    if (x.length === 0) {}\n    if (x.legnth === 0) { // typos are allowed to be tested\n      (x.legnth: number); // inside the block, it's a number\n      (x.legnth: string); // error: number literal 0 !~> string\n    }\n    if (y.length === 0) {}\n    if (y.legnth === 0) { // typos are allowed to be tested\n      (y.legnth: number); // inside the block, it's a number\n      (y.legnth: string); // error: number literal 0 !~> string\n    }\n    if (z.toString === 0) {}\n    if (z.toStirng === 0) { // typos are allowed to be tested\n      (z.toStirng: number); // inside the block, it's a number\n      (z.toStirng: string); // error: number literal 0 !~> string\n    }\n    if (q.valueOf === 0) {}\n    if (q.valeuOf === 0) { // typos are allowed to be tested\n      (q.valeuOf: number); // inside the block, it's a number\n      (q.valeuOf: string); // error: number literal 0 !~> string\n    }\n    if (r.toStirng === 0) { // typos are allowed to be tested\n      (r.toStirng: empty); // props on AnyObjT are \\`any\\`\n    }\n    if (s.call === 0) {}\n    if (s.calll === 0) { // typos are allowed to be tested\n      (t.calll: empty); // ok, props on functions are \\`any\\` :/\n    }\n    if (t.call === 0) {}\n    if (t.calll === 0) { // typos are allowed to be tested\n      (t.calll: empty); // ok, props on functions are \\`any\\` :/\n    }\n  },\n\n  // sentinel props become the RHS\n  function(x: { str: string, num: number, bool: boolean }) {\n    if (x.str === 'str') {\n      (x.str: 'not str'); // error: 'str' !~> 'not str'\n    }\n    if (x.num === 123) {\n      (x.num: 456); // error: 123 !~> 456\n    }\n    if (x.bool === true) {\n      (x.bool: false); // error: true !~> false\n    }\n    // even if it doesn't exist...\n    if (x.badStr === 'bad') {\n      (x.badStr: empty); // error: 'bad' !~> empty\n    }\n    if (x.badNum === 123) {\n      (x.badNum: empty); // error: 123 !~> empty\n    }\n    if (x.badBool === true) {\n      (x.badBool: empty); // error: true !~> empty\n    }\n  },\n\n  // type mismatch\n  function(x: { foo: 123, y: string } | { foo: 'foo', z: string }) {\n    if (x.foo === 123) {\n      (x.y: string);\n      x.z; // error\n    } else {\n      (x.z: string);\n      x.y; // error\n    }\n    if (x.foo === 'foo') {\n      (x.z: string);\n      x.y; // error\n    } else {\n      (x.y: string);\n      x.z; // error\n    }\n  },\n\n  // type mismatch, but one is not a literal\n  function(x: { foo: number, y: string } | { foo: 'foo', z: string }) {\n    if (x.foo === 123) {\n      (x.y: string); // ok, because 123 !== 'foo'\n      x.z; // error\n    } else {\n      x.y; // error: x.foo could be a string\n      x.z; // error: could still be either case (if foo was a different number)\n    }\n\n    if (x.foo === 'foo') {\n      (x.z: string);\n      x.y; // error\n    } else {\n      (x.y: string);\n      x.z; // error\n    }\n  },\n\n  // type mismatch, neither is a literal\n  function(x: { foo: number, y: string } | { foo: string, z: string }) {\n    if (x.foo === 123) {\n      (x.y: string); // ok, because 123 !== string\n      x.z; // error\n    } else {\n      x.y; // error: x.foo could be a string\n      x.z; // error: could still be either case (if foo was a different number)\n    }\n\n    if (x.foo === 'foo') {\n      (x.z: string);\n      x.y; // error\n    } else {\n      x.y; // error: x.foo could be a different string\n      x.z; // error: x.foo could be a number\n    }\n  },\n\n  // type mismatch, neither is a literal, test is not a literal either\n  function(\n    x: { foo: number, y: string } | { foo: string, z: string },\n    num: number\n  ) {\n    if (x.foo === num) {\n      x.y; // error: flow isn't smart enough to figure this out yet\n      x.z; // error\n    }\n  },\n\n  // null\n  function(x: { foo: null, y: string } | { foo: 'foo', z: string }) {\n    if (x.foo === null) {\n      (x.y: string);\n      x.z; // error\n    } else {\n      (x.z: string);\n      x.y; // error\n    }\n    if (x.foo === 'foo') {\n      (x.z: string);\n      x.y; // error\n    } else {\n      (x.y: string);\n      x.z; // error\n    }\n  },\n\n  // void\n  function(x: { foo: void, y: string } | { foo: 'foo', z: string }) {\n    if (x.foo === undefined) {\n      (x.y: string);\n      x.z; // error\n    } else {\n      (x.z: string);\n      x.y; // error\n    }\n    if (x.foo === 'foo') {\n      (x.z: string);\n      x.y; // error\n    } else {\n      (x.y: string);\n      x.z; // error\n    }\n  },\n];") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "// example 1\n\ntype Type = Name | ListType;\ntype Name = { kind: \"Name\", value: string };\ntype ListType = { kind: \"ListType\", name: string };\n\nfunction getTypeASTName(typeAST: Type): string {\n  if (typeAST.kind === \"Name\") {\n    return typeAST.value; // OK, since typeAST: Name\n  } else {\n    return typeAST.name; // OK, since typeAST: ListType\n  }\n}\n\n// example 2\nimport type { ASTNode } from \"./ast_node\";\nvar Node = require(\"./node1\"); // Node = \"Node1\"\nfunction foo(x: ASTNode) {\n  if (x.kind === Node) {\n    return x.prop1.charAt(0); // typeAST: Node1, but x.prop1 may be undefined\n  }\n  return null;\n}\n\n// example 3\ntype Apple = { kind: \"Fruit\", taste: \"Bad\" };\ntype Orange = { kind: \"Fruit\", taste: \"Good\" };\ntype Broccoli = { kind: \"Veg\", taste: \"Bad\", raw: \"No\" };\ntype Carrot = { kind: \"Veg\", taste: \"Good\", raw: \"Maybe\" };\n\ntype Breakfast = Apple | Orange | Broccoli | Carrot;\n\nfunction bar(x: Breakfast) {\n  if (x.kind === \"Fruit\") {\n    (x.taste: \"Good\");\n  } // error, Apple.taste = Bad\n  else (x.raw: \"No\"); // error, Carrot.raw = Maybe\n}\n\nfunction qux(x: Breakfast) {\n  if (x.taste === \"Good\") {\n    (x.raw: \"Yes\" | \"No\"); // 2 errors:\n    // Orange.raw doesn't exist\n    // Carrot.raw is neither Yes nor No\n  }\n}\n\n// example 4\nfunction list(n) {\n  if (n > 0) return { kind: \"cons\", next: list(n - 1) };\n  return { kind: \"nil\" };\n}\nfunction length(l) {\n  switch (l.kind) {\n    case \"cons\":\n      return 1 + length(l.next);\n    default:\n      return 0;\n  }\n}\nfunction check(n) {\n  if (n >= 0) return n === length(list(n));\n  return true;\n}\n\n// example 5\nvar EnumKind = { A: 1, B: 2, C: 3 };\ntype A = { kind: 1, A: number };\ntype B = { kind: 2, B: number };\ntype C = { kind: 3, C: number };\nfunction kind(x: A | B | C): number {\n  switch (x.kind) {\n    case EnumKind.A:\n      return x.A;\n    case EnumKind.B:\n      return x.B;\n    default:\n      return x.A; // error, x: C and property A not found in type C\n  }\n}\nkind({ kind: EnumKind.A, A: 1 });\n\n// example 6\ntype Citizen = { citizen: true };\ntype NonCitizen = { citizen: false, nationality: string };\nfunction nationality(x: Citizen | NonCitizen) {\n  if (x.citizen) return \"Shire\";\n  else return x.nationality;\n}\n\nlet tests = [\n  // non-existent props\n  function test7(x: A) {\n    if (x.kindTypo === 1) {\n      // typos are allowed to be tested\n      (x.kindTypo: string); // typos can't be used, though\n    }\n  },\n\n  // nested objects\n  function test8(x: { foo: { bar: 1 } }) {\n    if (x.foo.bar === 1) {\n    }\n    if (x.fooTypo.bar === 1) {\n    } // error, fooTypo doesn't exist\n  },\n\n  // invalid RHS\n  function (x: A) {\n    if (x.kind === null.toString()) {\n    } // error, method on null\n    if ({ kind: 1 }.kind === null.toString()) {\n    } // error, method on null\n  },\n\n  // non-objects on LHS\n  function (\n    x: Array<string>,\n    y: string,\n    z: number,\n    q: boolean,\n    r: Object,\n    s: Function,\n    t: () => void,\n  ) {\n    if (x.length === 0) {\n    }\n    if (x.legnth === 0) {\n      // typos are allowed to be tested\n      (x.legnth: number); // inside the block, it's a number\n      (x.legnth: string); // error: number literal 0 !~> string\n    }\n    if (y.length === 0) {\n    }\n    if (y.legnth === 0) {\n      // typos are allowed to be tested\n      (y.legnth: number); // inside the block, it's a number\n      (y.legnth: string); // error: number literal 0 !~> string\n    }\n    if (z.toString === 0) {\n    }\n    if (z.toStirng === 0) {\n      // typos are allowed to be tested\n      (z.toStirng: number); // inside the block, it's a number\n      (z.toStirng: string); // error: number literal 0 !~> string\n    }\n    if (q.valueOf === 0) {\n    }\n    if (q.valeuOf === 0) {\n      // typos are allowed to be tested\n      (q.valeuOf: number); // inside the block, it's a number\n      (q.valeuOf: string); // error: number literal 0 !~> string\n    }\n    if (r.toStirng === 0) {\n      // typos are allowed to be tested\n      (r.toStirng: empty); // props on AnyObjT are \\`any\\`\n    }\n    if (s.call === 0) {\n    }\n    if (s.calll === 0) {\n      // typos are allowed to be tested\n      (t.calll: empty); // ok, props on functions are \\`any\\` :/\n    }\n    if (t.call === 0) {\n    }\n    if (t.calll === 0) {\n      // typos are allowed to be tested\n      (t.calll: empty); // ok, props on functions are \\`any\\` :/\n    }\n  },\n\n  // sentinel props become the RHS\n  function (x: { str: string, num: number, bool: boolean }) {\n    if (x.str === \"str\") {\n      (x.str: \"not str\"); // error: 'str' !~> 'not str'\n    }\n    if (x.num === 123) {\n      (x.num: 456); // error: 123 !~> 456\n    }\n    if (x.bool === true) {\n      (x.bool: false); // error: true !~> false\n    }\n    // even if it doesn't exist...\n    if (x.badStr === \"bad\") {\n      (x.badStr: empty); // error: 'bad' !~> empty\n    }\n    if (x.badNum === 123) {\n      (x.badNum: empty); // error: 123 !~> empty\n    }\n    if (x.badBool === true) {\n      (x.badBool: empty); // error: true !~> empty\n    }\n  },\n\n  // type mismatch\n  function (x: { foo: 123, y: string } | { foo: \"foo\", z: string }) {\n    if (x.foo === 123) {\n      (x.y: string);\n      x.z; // error\n    } else {\n      (x.z: string);\n      x.y; // error\n    }\n    if (x.foo === \"foo\") {\n      (x.z: string);\n      x.y; // error\n    } else {\n      (x.y: string);\n      x.z; // error\n    }\n  },\n\n  // type mismatch, but one is not a literal\n  function (x: { foo: number, y: string } | { foo: \"foo\", z: string }) {\n    if (x.foo === 123) {\n      (x.y: string); // ok, because 123 !== 'foo'\n      x.z; // error\n    } else {\n      x.y; // error: x.foo could be a string\n      x.z; // error: could still be either case (if foo was a different number)\n    }\n\n    if (x.foo === \"foo\") {\n      (x.z: string);\n      x.y; // error\n    } else {\n      (x.y: string);\n      x.z; // error\n    }\n  },\n\n  // type mismatch, neither is a literal\n  function (x: { foo: number, y: string } | { foo: string, z: string }) {\n    if (x.foo === 123) {\n      (x.y: string); // ok, because 123 !== string\n      x.z; // error\n    } else {\n      x.y; // error: x.foo could be a string\n      x.z; // error: could still be either case (if foo was a different number)\n    }\n\n    if (x.foo === \"foo\") {\n      (x.z: string);\n      x.y; // error\n    } else {\n      x.y; // error: x.foo could be a different string\n      x.z; // error: x.foo could be a number\n    }\n  },\n\n  // type mismatch, neither is a literal, test is not a literal either\n  function (\n    x: { foo: number, y: string } | { foo: string, z: string },\n    num: number,\n  ) {\n    if (x.foo === num) {\n      x.y; // error: flow isn't smart enough to figure this out yet\n      x.z; // error\n    }\n  },\n\n  // null\n  function (x: { foo: null, y: string } | { foo: \"foo\", z: string }) {\n    if (x.foo === null) {\n      (x.y: string);\n      x.z; // error\n    } else {\n      (x.z: string);\n      x.y; // error\n    }\n    if (x.foo === \"foo\") {\n      (x.z: string);\n      x.y; // error\n    } else {\n      (x.y: string);\n      x.z; // error\n    }\n  },\n\n  // void\n  function (x: { foo: void, y: string } | { foo: \"foo\", z: string }) {\n    if (x.foo === undefined) {\n      (x.y: string);\n      x.z; // error\n    } else {\n      (x.z: string);\n      x.y; // error\n    }\n    if (x.foo === \"foo\") {\n      (x.z: string);\n      x.y; // error\n    } else {\n      (x.y: string);\n      x.z; // error\n    }\n  },\n];");
}
#[test]
fn test_tagged_union_import_js_format_1_66e547fe() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nimport { SUCCESS, ERROR } from './constants'\n\ntype Success = {\n  type: typeof SUCCESS,\n  message: string\n}\n\ntype Error = {\n  type: typeof ERROR,\n  error: string\n}\n\nfunction handleStatus(status: Success | Error) {\n  switch(status.type) {\n    case SUCCESS:\n      console.log(\\`Successful: \\${status.message}\\`);\n      break;\n    default:\n      console.log(\\`Errored: \\${status.error}\\`);\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nimport { SUCCESS, ERROR } from \"./constants\";\n\ntype Success = {\n  type: typeof SUCCESS,\n  message: string,\n};\n\ntype Error = {\n  type: typeof ERROR,\n  error: string,\n};\n\nfunction handleStatus(status: Success | Error) {\n  switch (status.type) {\n    case SUCCESS:\n      console.log(\\`Successful: \\${status.message}\\`);\n      break;\n    default:\n      console.log(\\`Errored: \\${status.error}\\`);\n  }\n}");
}
#[test]
fn test_typeof_js_format_1_2dd33ecc() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nfunction foo(x: bool | number) {\n  if (typeof x === \"boolean\") {\n    x[0]; // error for boolean, not number\n  }\n}\n\nfunction bar(): number {\n  var x = null;\n  if (typeof x === \"object\") {\n    return x; // error, null\n  }\n  return 0;\n}\n\n/* refining globals */\nfunction fn0() {\n  if (typeof BAZ !== 'undefined' &&\n      typeof BAZ.stuff === 'function') {\n    BAZ.stuff(123);\n  }\n  BAZ.stuff(123); // error, refinement is gone\n}\nfunction fn1() {\n  BAZ.stuff; // error, could be undefined\n  if (typeof BAZ !== 'undefined' &&\n      typeof BAZ.stuff === 'function') {\n    BAZ.stuff(123); // ok\n    BAZ.stuff(123); // error, refinement is gone\n  }\n}\n\nfunction anyfun(x: number | Function): number {\n  if (typeof x === \"function\") {\n    return 0;\n  }\n  return x; // OK, x refined to \\`number\\`\n}\n\nfunction anyobj(x: number | Object): number {\n  if (typeof x === \"object\") {\n    return 0;\n  }\n  return x; // OK, x refined to \\`number\\`\n}\n\nfunction testInvalidValue(x: mixed) {\n  if (typeof x === \"foo\") { // error\n    return 0;\n  }\n}\n\nfunction testTemplateLiteral(x: string | number) {\n  if (typeof x === \\`string\\`) {\n    return x.length;\n  }\n}\n\nfunction testInvalidTemplateLiteral(x: string | number) {\n  if (typeof x === \\`foo\\`) { // error\n    return 0;\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nfunction foo(x: boolean | number) {\n  if (typeof x === \"boolean\") {\n    x[0]; // error for boolean, not number\n  }\n}\n\nfunction bar(): number {\n  var x = null;\n  if (typeof x === \"object\") {\n    return x; // error, null\n  }\n  return 0;\n}\n\n/* refining globals */\nfunction fn0() {\n  if (typeof BAZ !== \"undefined\" && typeof BAZ.stuff === \"function\") {\n    BAZ.stuff(123);\n  }\n  BAZ.stuff(123); // error, refinement is gone\n}\nfunction fn1() {\n  BAZ.stuff; // error, could be undefined\n  if (typeof BAZ !== \"undefined\" && typeof BAZ.stuff === \"function\") {\n    BAZ.stuff(123); // ok\n    BAZ.stuff(123); // error, refinement is gone\n  }\n}\n\nfunction anyfun(x: number | Function): number {\n  if (typeof x === \"function\") {\n    return 0;\n  }\n  return x; // OK, x refined to \\`number\\`\n}\n\nfunction anyobj(x: number | Object): number {\n  if (typeof x === \"object\") {\n    return 0;\n  }\n  return x; // OK, x refined to \\`number\\`\n}\n\nfunction testInvalidValue(x: mixed) {\n  if (typeof x === \"foo\") {\n    // error\n    return 0;\n  }\n}\n\nfunction testTemplateLiteral(x: string | number) {\n  if (typeof x === \\`string\\`) {\n    return x.length;\n  }\n}\n\nfunction testInvalidTemplateLiteral(x: string | number) {\n  if (typeof x === \\`foo\\`) {\n    // error\n    return 0;\n  }\n}");
}
#[test]
fn test_undef_js_format_1_221825ee() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nfunction undef_var(x: ?number) {\n  if (x !== null && x !== undefined) {\n    var y = x * 1000;\n  }\n}\n\nfunction undef_var_rev(x: ?number) {\n  if (x === null || x === undefined) {\n  } else {\n    var y = x * 1000;\n  }\n}\n\nfunction undef_prop(x: { x: ?number }) {\n  if (x.x !== null && x.x !== undefined) {\n    var y = x.x * 1000;\n  }\n}\n\nfunction undef_prop_rev(x: { x: ?number }) {\n  if (x.x === null || x.x === undefined) {\n  } else {\n    var y = x.x * 1000;\n  }\n}\n\nfunction undef_var_fail(x: ?number) {\n  if (x !== undefined) {\n    var y = x * 1000;\n  }\n}\n\nfunction undef_var_fail_rev(x: ?number) {\n  if (x === undefined) {\n  } else {\n    var y = x * 1000;\n  }\n}\n\nfunction undef_prop_fail(x: { x: ?number }) {\n  if (x.x !== undefined) {\n    var y = x.x * 1000;\n  }\n}\n\nfunction undef_prop_fail_rev(x: { x: ?number }) {\n  if (x.x === undefined) {\n  } else {\n    var y = x.x * 1000;\n  }\n}\n\nfunction undef_unreachable(x: number) {\n  if (x === undefined) {\n    var y = x * 1000; // unreachable\n  }\n  if (x == undefined) {\n    var z = x * 1000; // unreachable\n  }\n}\n\nfunction undef_var_nonstrict(x: ?number, y: ?number) {\n  if (x != undefined) {\n    var a = x * 1000;\n  }\n  if (y == undefined){\n    var b = y * 1000; // error\n  }\n}\n\nfunction undef_bogus_comparison() {\n  if (100 * undefined) {\n    return;\n  }\n  if (undefined * 100) {\n    return;\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nfunction undef_var(x: ?number) {\n  if (x !== null && x !== undefined) {\n    var y = x * 1000;\n  }\n}\n\nfunction undef_var_rev(x: ?number) {\n  if (x === null || x === undefined) {\n  } else {\n    var y = x * 1000;\n  }\n}\n\nfunction undef_prop(x: { x: ?number }) {\n  if (x.x !== null && x.x !== undefined) {\n    var y = x.x * 1000;\n  }\n}\n\nfunction undef_prop_rev(x: { x: ?number }) {\n  if (x.x === null || x.x === undefined) {\n  } else {\n    var y = x.x * 1000;\n  }\n}\n\nfunction undef_var_fail(x: ?number) {\n  if (x !== undefined) {\n    var y = x * 1000;\n  }\n}\n\nfunction undef_var_fail_rev(x: ?number) {\n  if (x === undefined) {\n  } else {\n    var y = x * 1000;\n  }\n}\n\nfunction undef_prop_fail(x: { x: ?number }) {\n  if (x.x !== undefined) {\n    var y = x.x * 1000;\n  }\n}\n\nfunction undef_prop_fail_rev(x: { x: ?number }) {\n  if (x.x === undefined) {\n  } else {\n    var y = x.x * 1000;\n  }\n}\n\nfunction undef_unreachable(x: number) {\n  if (x === undefined) {\n    var y = x * 1000; // unreachable\n  }\n  if (x == undefined) {\n    var z = x * 1000; // unreachable\n  }\n}\n\nfunction undef_var_nonstrict(x: ?number, y: ?number) {\n  if (x != undefined) {\n    var a = x * 1000;\n  }\n  if (y == undefined) {\n    var b = y * 1000; // error\n  }\n}\n\nfunction undef_bogus_comparison() {\n  if (100 * undefined) {\n    return;\n  }\n  if (undefined * 100) {\n    return;\n  }\n}");
}
#[test]
fn test_union_js_format_1_2d630df8() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\ntype thing = number | bool\n\nfunction foo(x: thing) {\n  if (x === true) {\n    x[0]; // error on boolean\n  }\n}\n\nfunction bar(x: thing) {\n  if (x !== true && x !== false) {\n    x[0]; // error on number\n  }\n}\n\nfunction baz(x: ?thing) {\n  if (x && x !== true) {\n    x[0]; // error on number\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\ntype thing = number | boolean;\n\nfunction foo(x: thing) {\n  if (x === true) {\n    x[0]; // error on boolean\n  }\n}\n\nfunction bar(x: thing) {\n  if (x !== true && x !== false) {\n    x[0]; // error on number\n  }\n}\n\nfunction baz(x: ?thing) {\n  if (x && x !== true) {\n    x[0]; // error on number\n  }\n}");
}
#[test]
fn test_void_js_format_1_c17969c7() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nfunction void_var(x: ?number) {\n  if (x !== null && x !== void(0)) {\n    var y = x * 1000;\n  }\n}\n\nfunction void_var_rev(x: ?number) {\n  if (x === null || x === void(0)) {\n  } else {\n    var y = x * 1000;\n  }\n}\n\nfunction void_pro(x: { x: ?number }) {\n  if (x.x !== null && x.x !== void(0)) {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_pro_rev(x: { x: ?number }) {\n  if (x.x === null || x.x === void(0)) {\n  } else {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_var_fail(x: ?number) {\n  if (x !== void(0)) {\n    var y = x * 1000;\n  }\n}\n\nfunction void_var_fail_rev(x: ?number) {\n  if (x === void(0)) {\n  } else {\n    var y = x * 1000;\n  }\n}\n\nfunction void_pro_fail(x: { x: ?number }) {\n  if (x.x !== void(0)) {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_pro_fail_rev(x: { x: ?number }) {\n  if (x.x === void(0)) {\n  } else {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_var_side_effect(x: ?number) {\n  if (x !== null && x !== void(x * 1000)) {\n    var y = x * 1000;\n  }\n}\n\nfunction void_var_side_effect_rev(x: ?number) {\n  if (x === null || x === void(x * 1000)) {\n  } else {\n    var y = x * 1000;\n  }\n}\n\nfunction void_prop_side_effect(x: { x: ?number }) {\n  if (x.x !== null && x.x !== void(x.x * 1000)) {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_prop_side_effect_rev(x: { x: ?number }) {\n  if (x.x === null || x.x === void(x.x * 1000)) {\n  } else {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_bogus_comparison() {\n  if (100 * void(0)) {\n    return;\n  }\n  if (void(0) * 100) {\n    return;\n  }\n}\n\nfunction void_redefined_undefined(x: ?number) {\n  var undefined = \"foo\";\n  if (x !== null && x !== void(0)) {\n    var y = x * 1000;\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nfunction void_var(x: ?number) {\n  if (x !== null && x !== void 0) {\n    var y = x * 1000;\n  }\n}\n\nfunction void_var_rev(x: ?number) {\n  if (x === null || x === void 0) {\n  } else {\n    var y = x * 1000;\n  }\n}\n\nfunction void_pro(x: { x: ?number }) {\n  if (x.x !== null && x.x !== void 0) {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_pro_rev(x: { x: ?number }) {\n  if (x.x === null || x.x === void 0) {\n  } else {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_var_fail(x: ?number) {\n  if (x !== void 0) {\n    var y = x * 1000;\n  }\n}\n\nfunction void_var_fail_rev(x: ?number) {\n  if (x === void 0) {\n  } else {\n    var y = x * 1000;\n  }\n}\n\nfunction void_pro_fail(x: { x: ?number }) {\n  if (x.x !== void 0) {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_pro_fail_rev(x: { x: ?number }) {\n  if (x.x === void 0) {\n  } else {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_var_side_effect(x: ?number) {\n  if (x !== null && x !== void (x * 1000)) {\n    var y = x * 1000;\n  }\n}\n\nfunction void_var_side_effect_rev(x: ?number) {\n  if (x === null || x === void (x * 1000)) {\n  } else {\n    var y = x * 1000;\n  }\n}\n\nfunction void_prop_side_effect(x: { x: ?number }) {\n  if (x.x !== null && x.x !== void (x.x * 1000)) {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_prop_side_effect_rev(x: { x: ?number }) {\n  if (x.x === null || x.x === void (x.x * 1000)) {\n  } else {\n    var y = x.x * 1000;\n  }\n}\n\nfunction void_bogus_comparison() {\n  if (100 * void 0) {\n    return;\n  }\n  if (void 0 * 100) {\n    return;\n  }\n}\n\nfunction void_redefined_undefined(x: ?number) {\n  var undefined = \"foo\";\n  if (x !== null && x !== void 0) {\n    var y = x * 1000;\n  }\n}");
}
