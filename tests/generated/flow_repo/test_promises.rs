#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[test]
fn test_all_js_format_1_8345a6a2() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("// @flow\n\ndeclare var pstr: Promise<string>;\ndeclare var pnum: Promise<number>;\n\nPromise.all([\n  pstr,\n  pnum,\n  true, // non-Promise values passed through\n]).then((xs) => {\n  // tuple information is preserved\n  let [a,b,c] = xs;\n  (a: number);  // Error: string ~> number\n  (b: boolean); // Error: number ~> boolean\n  (c: string);  // Error: boolean ~> string\n\n  // array element type is (string | number | boolean)\n  xs.forEach(x => {\n    (x: void);  // Errors: string ~> void, number ~> void, boolean ~> void\n  });\n});\n\n// First argument is required\nPromise.all(); // Error: expected array instead of undefined (too few arguments)\n\n// Mis-typed arg\nPromise.all(0); // Error: expected array instead of number\n\n// Promise.all is a function\n(Promise.all : Function);\n\n// Promise.all supports iterables\nfunction test(val: Iterable<Promise<number>>) {\n  const r: Promise<Array<number>> = Promise.all(val);\n}\n\nfunction tes2(val: Map<string, Promise<number>>) {\n  const r: Promise<Array<number>> = Promise.all(val.values());\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "// @flow\n\ndeclare var pstr: Promise<string>;\ndeclare var pnum: Promise<number>;\n\nPromise.all([\n  pstr,\n  pnum,\n  true, // non-Promise values passed through\n]).then((xs) => {\n  // tuple information is preserved\n  let [a, b, c] = xs;\n  (a: number); // Error: string ~> number\n  (b: boolean); // Error: number ~> boolean\n  (c: string); // Error: boolean ~> string\n\n  // array element type is (string | number | boolean)\n  xs.forEach((x) => {\n    (x: void); // Errors: string ~> void, number ~> void, boolean ~> void\n  });\n});\n\n// First argument is required\nPromise.all(); // Error: expected array instead of undefined (too few arguments)\n\n// Mis-typed arg\nPromise.all(0); // Error: expected array instead of number\n\n// Promise.all is a function\n(Promise.all: Function);\n\n// Promise.all supports iterables\nfunction test(val: Iterable<Promise<number>>) {\n  const r: Promise<Array<number>> = Promise.all(val);\n}\n\nfunction tes2(val: Map<string, Promise<number>>) {\n  const r: Promise<Array<number>> = Promise.all(val.values());\n}");
}
#[test]
fn test_covariance_js_format_1_3c70c94e() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("/* @flow */\n\nasync function testAll() {\n  /* This is a test case from https://github.com/facebook/flow/issues/1143\n   * which was previously an error due to Array's invariance and an improper\n   * definition of Promise.all */\n    const x: Array<Promise<?string>> = [];\n    const y: Promise<Array<?string>> = Promise.all(x);\n    const z: Array<?string> = await y;\n}\n\nasync function testRace() {\n    const x: Array<Promise<?string>> = [];\n    const y: Promise<?string> = Promise.race(x);\n    const z: ?string = await y;\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/* @flow */\n\nasync function testAll() {\n  /* This is a test case from https://github.com/facebook/flow/issues/1143\n   * which was previously an error due to Array's invariance and an improper\n   * definition of Promise.all */\n  const x: Array<Promise<?string>> = [];\n  const y: Promise<Array<?string>> = Promise.all(x);\n  const z: Array<?string> = await y;\n}\n\nasync function testRace() {\n  const x: Array<Promise<?string>> = [];\n  const y: Promise<?string> = Promise.race(x);\n  const z: ?string = await y;\n}");
}
#[test]
fn test_promise_js_format_1_ff5cea53() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("/**\n * @flow\n */\n\n//////////////////////////////////////////////////\n// == Promise constructor resolve() function == //\n//////////////////////////////////////////////////\n\n// Promise constructor resolve(T) -> then(T)\nnew Promise(function(resolve, reject) {\n  resolve(0);\n}).then(function(num) {\n  var a: number = num;\n\n  // TODO: The error message that results from this is almost useless\n  var b: string = num; // Error: number ~> string\n});\n\n// Promise constructor with arrow function resolve(T) -> then(T)\nnew Promise((resolve, reject) => resolve(0))\n  .then(function(num) {\n    var a: number = num;\n\n    // TODO: The error message that results from this is almost useless\n    var b: string = num; // Error: number ~> string\n  });\n\n// Promise constructor resolve(Promise<T>) -> then(T)\nnew Promise(function(resolve, reject) {\n  resolve(new Promise(function(resolve, reject) {\n    resolve(0);\n  }));\n}).then(function(num) {\n  var a: number = num;\n  var b: string = num; // Error: number ~> string\n});\n\n// Promise constructor resolve(Promise<Promise<T>>) -> then(T)\nnew Promise(function(resolve, reject) {\n  resolve(new Promise(function(resolve, reject) {\n    resolve(new Promise(function(resolve, reject) {\n      resolve(0);\n    }));\n  }));\n}).then(function(num) {\n  var a: number = num;\n  var b: string = num; // Error: number ~> string\n});\n\n// Promise constructor resolve(T); resolve(U); -> then(T|U)\nnew Promise(function(resolve, reject) {\n  if (Math.random()) {\n    resolve(42);\n  } else {\n    resolve('str');\n  }\n}).then(function(numOrStr) {\n  if (typeof numOrStr === 'string') {\n    var a: string = numOrStr;\n  } else {\n    var b: number = numOrStr;\n  }\n  var c: string = numOrStr; // Error: number|string -> string\n});\n\n/////////////////////////////////////////////////\n// == Promise constructor reject() function == //\n/////////////////////////////////////////////////\n\n// TODO: Promise constructor reject(T) -> catch(T)\nnew Promise(function(resolve, reject) {\n  reject(0);\n}).catch(function(num) {\n  var a: number = num;\n\n  // TODO\n  var b: string = num; // Error: number ~> string\n});\n\n// TODO: Promise constructor reject(Promise<T>) ~> catch(Promise<T>)\nnew Promise(function(resolve, reject) {\n  reject(new Promise(function(resolve, reject) {\n    reject(0);\n  }));\n}).catch(function(num) {\n  var a: Promise<number> = num;\n\n  // TODO\n  var b: number = num; // Error: Promise<Number> ~> number\n});\n\n// TODO: Promise constructor reject(T); reject(U); -> then(T|U)\nnew Promise(function(resolve, reject) {\n  if (Math.random()) {\n    reject(42);\n  } else {\n    reject('str');\n  }\n}).catch(function(numOrStr) {\n  if (typeof numOrStr === 'string') {\n    var a: string = numOrStr;\n  } else {\n    var b: number = numOrStr;\n  }\n\n  // TODO\n  var c: string = numOrStr; // Error: number|string -> string\n});\n\n/////////////////////////////\n// == Promise.resolve() == //\n/////////////////////////////\n\n// Promise.resolve(T) -> then(T)\nPromise.resolve(0).then(function(num) {\n  var a: number = num;\n  var b: string = num; // Error: number ~> string\n});\n\n// Promise.resolve(Promise<T>) -> then(T)\nPromise.resolve(Promise.resolve(0)).then(function(num) {\n  var a: number = num;\n  var b: string = num; // Error: number ~> string\n});\n\n// Promise.resolve(Promise<Promise<T>>) -> then(T)\nPromise.resolve(Promise.resolve(Promise.resolve(0))).then(function(num) {\n  var a: number = num;\n  var b: string = num; // Error: number ~> string\n});\n\n////////////////////////////\n// == Promise.reject() == //\n////////////////////////////\n\n// TODO: Promise.reject(T) -> catch(T)\nPromise.reject(0).catch(function(num) {\n  var a: number = num;\n\n  // TODO\n  var b: string = num; // Error: number ~> string\n});\n\n// TODO: Promise.reject(Promise<T>) -> catch(Promise<T>)\nPromise.reject(Promise.resolve(0)).then(function(num) {\n  var a: Promise<number> = num;\n\n  // TODO\n  var b: number = num; // Error: Promise<number> ~> number\n});\n\n//////////////////////////////////\n// == Promise.prototype.then == //\n//////////////////////////////////\n\n// resolvedPromise.then():T -> then(T)\nPromise.resolve(0)\n  .then(function(num) { return 'asdf'; })\n  .then(function(str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// resolvedPromise.then():Promise<T> -> then(T)\nPromise.resolve(0)\n  .then(function(num) { return Promise.resolve('asdf'); })\n  .then(function(str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// resolvedPromise.then():Promise<Promise<T>> -> then(T)\nPromise.resolve(0)\n  .then(function(num) { return Promise.resolve(Promise.resolve('asdf')); })\n  .then(function(str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// TODO: resolvedPromise.then(<throw(T)>) -> catch(T)\nPromise.resolve(0)\n  .then(function(num) {\n    throw 'str';\n  })\n  .catch(function(str) {\n    var a: string = str;\n\n    // TODO\n    var b: number = str; // Error: string ~> number\n  });\n\n///////////////////////////////////\n// == Promise.prototype.catch == //\n///////////////////////////////////\n\n// rejectedPromise.catch():U -> then(U)\nPromise.reject(0)\n  .catch(function(num) { return 'asdf'; })\n  .then(function(str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// rejectedPromise.catch():Promise<U> -> then(U)\nPromise.reject(0)\n  .catch(function(num) { return Promise.resolve('asdf'); })\n  .then(function(str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// rejectedPromise.catch():Promise<Promise<U>> -> then(U)\nPromise.reject(0)\n  .catch(function(num) { return Promise.resolve(Promise.resolve('asdf')); })\n  .then(function(str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// resolvedPromise<T> -> catch() -> then():?T\nPromise.resolve(0)\n  .catch(function(err) {})\n  .then(function(num) {\n    var a: ?number = num;\n    var b: string = num; // Error: string ~> number\n  });") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/**\n * @flow\n */\n\n//////////////////////////////////////////////////\n// == Promise constructor resolve() function == //\n//////////////////////////////////////////////////\n\n// Promise constructor resolve(T) -> then(T)\nnew Promise(function (resolve, reject) {\n  resolve(0);\n}).then(function (num) {\n  var a: number = num;\n\n  // TODO: The error message that results from this is almost useless\n  var b: string = num; // Error: number ~> string\n});\n\n// Promise constructor with arrow function resolve(T) -> then(T)\nnew Promise((resolve, reject) => resolve(0)).then(function (num) {\n  var a: number = num;\n\n  // TODO: The error message that results from this is almost useless\n  var b: string = num; // Error: number ~> string\n});\n\n// Promise constructor resolve(Promise<T>) -> then(T)\nnew Promise(function (resolve, reject) {\n  resolve(\n    new Promise(function (resolve, reject) {\n      resolve(0);\n    }),\n  );\n}).then(function (num) {\n  var a: number = num;\n  var b: string = num; // Error: number ~> string\n});\n\n// Promise constructor resolve(Promise<Promise<T>>) -> then(T)\nnew Promise(function (resolve, reject) {\n  resolve(\n    new Promise(function (resolve, reject) {\n      resolve(\n        new Promise(function (resolve, reject) {\n          resolve(0);\n        }),\n      );\n    }),\n  );\n}).then(function (num) {\n  var a: number = num;\n  var b: string = num; // Error: number ~> string\n});\n\n// Promise constructor resolve(T); resolve(U); -> then(T|U)\nnew Promise(function (resolve, reject) {\n  if (Math.random()) {\n    resolve(42);\n  } else {\n    resolve(\"str\");\n  }\n}).then(function (numOrStr) {\n  if (typeof numOrStr === \"string\") {\n    var a: string = numOrStr;\n  } else {\n    var b: number = numOrStr;\n  }\n  var c: string = numOrStr; // Error: number|string -> string\n});\n\n/////////////////////////////////////////////////\n// == Promise constructor reject() function == //\n/////////////////////////////////////////////////\n\n// TODO: Promise constructor reject(T) -> catch(T)\nnew Promise(function (resolve, reject) {\n  reject(0);\n}).catch(function (num) {\n  var a: number = num;\n\n  // TODO\n  var b: string = num; // Error: number ~> string\n});\n\n// TODO: Promise constructor reject(Promise<T>) ~> catch(Promise<T>)\nnew Promise(function (resolve, reject) {\n  reject(\n    new Promise(function (resolve, reject) {\n      reject(0);\n    }),\n  );\n}).catch(function (num) {\n  var a: Promise<number> = num;\n\n  // TODO\n  var b: number = num; // Error: Promise<Number> ~> number\n});\n\n// TODO: Promise constructor reject(T); reject(U); -> then(T|U)\nnew Promise(function (resolve, reject) {\n  if (Math.random()) {\n    reject(42);\n  } else {\n    reject(\"str\");\n  }\n}).catch(function (numOrStr) {\n  if (typeof numOrStr === \"string\") {\n    var a: string = numOrStr;\n  } else {\n    var b: number = numOrStr;\n  }\n\n  // TODO\n  var c: string = numOrStr; // Error: number|string -> string\n});\n\n/////////////////////////////\n// == Promise.resolve() == //\n/////////////////////////////\n\n// Promise.resolve(T) -> then(T)\nPromise.resolve(0).then(function (num) {\n  var a: number = num;\n  var b: string = num; // Error: number ~> string\n});\n\n// Promise.resolve(Promise<T>) -> then(T)\nPromise.resolve(Promise.resolve(0)).then(function (num) {\n  var a: number = num;\n  var b: string = num; // Error: number ~> string\n});\n\n// Promise.resolve(Promise<Promise<T>>) -> then(T)\nPromise.resolve(Promise.resolve(Promise.resolve(0))).then(function (num) {\n  var a: number = num;\n  var b: string = num; // Error: number ~> string\n});\n\n////////////////////////////\n// == Promise.reject() == //\n////////////////////////////\n\n// TODO: Promise.reject(T) -> catch(T)\nPromise.reject(0).catch(function (num) {\n  var a: number = num;\n\n  // TODO\n  var b: string = num; // Error: number ~> string\n});\n\n// TODO: Promise.reject(Promise<T>) -> catch(Promise<T>)\nPromise.reject(Promise.resolve(0)).then(function (num) {\n  var a: Promise<number> = num;\n\n  // TODO\n  var b: number = num; // Error: Promise<number> ~> number\n});\n\n//////////////////////////////////\n// == Promise.prototype.then == //\n//////////////////////////////////\n\n// resolvedPromise.then():T -> then(T)\nPromise.resolve(0)\n  .then(function (num) {\n    return \"asdf\";\n  })\n  .then(function (str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// resolvedPromise.then():Promise<T> -> then(T)\nPromise.resolve(0)\n  .then(function (num) {\n    return Promise.resolve(\"asdf\");\n  })\n  .then(function (str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// resolvedPromise.then():Promise<Promise<T>> -> then(T)\nPromise.resolve(0)\n  .then(function (num) {\n    return Promise.resolve(Promise.resolve(\"asdf\"));\n  })\n  .then(function (str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// TODO: resolvedPromise.then(<throw(T)>) -> catch(T)\nPromise.resolve(0)\n  .then(function (num) {\n    throw \"str\";\n  })\n  .catch(function (str) {\n    var a: string = str;\n\n    // TODO\n    var b: number = str; // Error: string ~> number\n  });\n\n///////////////////////////////////\n// == Promise.prototype.catch == //\n///////////////////////////////////\n\n// rejectedPromise.catch():U -> then(U)\nPromise.reject(0)\n  .catch(function (num) {\n    return \"asdf\";\n  })\n  .then(function (str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// rejectedPromise.catch():Promise<U> -> then(U)\nPromise.reject(0)\n  .catch(function (num) {\n    return Promise.resolve(\"asdf\");\n  })\n  .then(function (str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// rejectedPromise.catch():Promise<Promise<U>> -> then(U)\nPromise.reject(0)\n  .catch(function (num) {\n    return Promise.resolve(Promise.resolve(\"asdf\"));\n  })\n  .then(function (str) {\n    var a: string = str;\n    var b: number = str; // Error: string ~> number\n  });\n\n// resolvedPromise<T> -> catch() -> then():?T\nPromise.resolve(0)\n  .catch(function (err) {})\n  .then(function (num) {\n    var a: ?number = num;\n    var b: string = num; // Error: string ~> number\n  });");
}
#[test]
fn test_resolve_global_js_format_1_95ce023d() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("/**\n * test Promise name resolution\n * @flow\n */\n\n/**\n * 1. introduce shadowing bindings for important names\n */\nclass Promise {}\n\n/**\n * 2. implicit refs to Promise during desugaring should be unaffected\n */\nasync function foo(x: boolean) {\n  if (x) {\n    return {bar: 'baz'};\n  } else {\n    return null;\n  }\n}\n\nasync function run() {\n  console.log(await foo(true));\n  console.log(await foo(false));\n}\n\nrun();\n\n/**\n * 3. but explicit name refs from code and annos resolve\n * using the usual rules\n */\n// error: \\`Promise\\` in return expr is the local binding\nasync function bar() {\n  return Promise.resolve(0);\n}\n\n// error: return type anno is a ref to the local binding\nasync function baz(): Promise<number> {\n  return 0;\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/**\n * test Promise name resolution\n * @flow\n */\n\n/**\n * 1. introduce shadowing bindings for important names\n */\nclass Promise {}\n\n/**\n * 2. implicit refs to Promise during desugaring should be unaffected\n */\nasync function foo(x: boolean) {\n  if (x) {\n    return { bar: \"baz\" };\n  } else {\n    return null;\n  }\n}\n\nasync function run() {\n  console.log(await foo(true));\n  console.log(await foo(false));\n}\n\nrun();\n\n/**\n * 3. but explicit name refs from code and annos resolve\n * using the usual rules\n */\n// error: \\`Promise\\` in return expr is the local binding\nasync function bar() {\n  return Promise.resolve(0);\n}\n\n// error: return type anno is a ref to the local binding\nasync function baz(): Promise<number> {\n  return 0;\n}");
}
#[test]
fn test_resolve_void_js_format_1_fb5bab31() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("// @flow\n\n(Promise.resolve(): Promise<number>); // error\n\n(Promise.resolve(undefined): Promise<number>); // error") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "// @flow\n\n(Promise.resolve(): Promise<number>); // error\n\n(Promise.resolve(undefined): Promise<number>); // error");
}
