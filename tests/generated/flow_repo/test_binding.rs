#[allow(unused_imports)]
use anyhow::Result;
#[allow(unused_imports)]
use pretty_assertions::assert_eq;
#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[allow(dead_code)]
static INFINITY: usize = usize::MAX;
#[test]
fn test_const_js_format_1_c79a14c1() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("const x = 0;\n\n// errors: const cannot be reassigned\nx++;\nx--;\nx += 0;\nx -= 0;\nx /= 0;\nx %= 0;\nx <<= 0\nx >>= 0;\nx >>>= 0;\nx |= 0;\nx ^= 0;\nx &= 0;\n\n// regression tests -- OK to assign consts like this:\n\nconst { foo } = { foo: \"foo\" }\nconst [ bar ] = [\"bar\"];\n(foo: number); // error: string ~> number\n(bar: number); // error: string ~> number\n\ndeclare var bazzes: { baz: string }[];\nfor (const { baz } of bazzes) {\n  (baz: number); // error: string ~> number\n}") ? ;
    assert_eq ! (formatted , "const x = 0;\n\n// errors: const cannot be reassigned\nx++;\nx--;\nx += 0;\nx -= 0;\nx /= 0;\nx %= 0;\nx <<= 0;\nx >>= 0;\nx >>>= 0;\nx |= 0;\nx ^= 0;\nx &= 0;\n\n// regression tests -- OK to assign consts like this:\n\nconst { foo } = { foo: \"foo\" };\nconst [bar] = [\"bar\"];\n(foo: number); // error: string ~> number\n(bar: number); // error: string ~> number\n\ndeclare var bazzes: { baz: string }[];\nfor (const { baz } of bazzes) {\n  (baz: number); // error: string ~> number\n}");
    Ok(())
}
#[test]
fn test_rebinding_js_format_1_c4f6c5df() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/* @flow\n * test errors on illegal rebinding/reassignment\n *\n *       type class let const var (reassign)\n * type  x    x      x   x     x   x\n * class x    x      x   x     x\n * let   x    x      x   x     x\n * const x    x      x   x     x   x\n * var   x    x      x   x\n */\n\n// type x *\n\nfunction type_type() {\n  type A = number;\n  type A = number;  // error: name already bound\n}\n\nfunction type_class() {\n  type A = number;\n  class A {}        // error: name already bound\n}\n\nfunction type_let() {\n  type A = number;\n  let A = 0;        // error: name already bound\n}\n\nfunction type_const() {\n  type A = number;\n  const A = 0;     // error: name already bound\n}\n\nfunction type_var() {\n  type A = number;\n  var A = 0;        // error: name already bound\n}\n\nfunction type_reassign() {\n  type A = number;\n  A = 42;           // error: type alias ref'd from value pos\n}\n\n// class x *\n\nfunction class_type() {\n  class A {}\n  type A = number;  // error: name already bound\n}\n\nfunction class_class() {\n  class A {}\n  class A {}        // error: name already bound\n}\n\nfunction class_let() {\n  class A {}\n  let A = 0;        // error: name already bound\n}\n\nfunction class_const() {\n  class A {}\n  const A = 0;     // error: name already bound\n}\n\nfunction class_var() {\n  class A {}\n  var A = 0;        // error: name already bound\n}\n\n// let x *\n\nfunction let_type() {\n  let A = 0;\n  type A = number;  // error: name already bound\n}\n\nfunction let_class() {\n  let A = 0;\n  class A {}        // error: name already bound\n}\n\nfunction let_let() {\n  let A = 0;\n  let A = 0;        // error: name already bound\n}\n\nfunction let_const() {\n  let A = 0;\n  const A = 0;     // error: name already bound\n}\n\nfunction let_var() {\n  let A = 0;\n  var A = 0;        // error: name already bound\n}\n\n// const x *\n\nfunction const_type() {\n  const A = 0;\n  type A = number;  // error: name already bound\n}\n\nfunction const_class() {\n  const A = 0;\n  class A {}        // error: name already bound\n}\n\nfunction const_let() {\n  const A = 0;\n  let A = 0;        // error: name already bound\n}\n\nfunction const_const() {\n  const A = 0;\n  const A = 0;     // error: name already bound\n}\n\nfunction const_var() {\n  const A = 0;\n  var A = 0;        // error: name already bound\n}\n\nfunction const_reassign() {\n  const A = 0;\n  A = 42;           // error: cannot be reassigned\n}\n\n// var x *\n\nfunction var_type() {\n  var A = 0;\n  type A = number;  // error: name already bound\n}\n\nfunction var_class() {\n  var A = 0;\n  class A {}        // error: name already bound\n}\n\nfunction var_let() {\n  var A = 0;\n  let A = 0;        // error: name already bound\n}\n\nfunction var_const() {\n  var A = 0;\n  const A = 0;      // error: name already bound\n}\n\nfunction var_var() {\n  var A = 0;\n  var A = 0;       // OK\n}\n\n// function x *\n\nfunction function_toplevel() {\n  function a() {};\n  function a() {}; // OK\n}\n\nfunction function_block() {\n  {\n    function a() {};\n    function a() {}; // error: name already bound\n  }\n}\n\n// corner cases\n\nfunction var_shadow_nested_scope() {\n  {\n    let x = 0;\n    {\n      var x = 0; // error: name already bound\n    }\n  }\n}\n\nfunction type_shadow_nested_scope() {\n  {\n    let x = 0;\n    {\n      type x = string; // error: name already bound\n    }\n  }\n}\n\n// fn params name clash\n\nfunction fn_params_name_clash(x, x /* error: x already bound */) {}\nfunction fn_params_clash_fn_binding(x,y) {\n  let x = 0; // error: x already bound\n  var y = 0; // OK\n}") ? ;
    assert_eq ! (formatted , "/* @flow\n * test errors on illegal rebinding/reassignment\n *\n *       type class let const var (reassign)\n * type  x    x      x   x     x   x\n * class x    x      x   x     x\n * let   x    x      x   x     x\n * const x    x      x   x     x   x\n * var   x    x      x   x\n */\n\n// type x *\n\nfunction type_type() {\n  type A = number;\n  type A = number; // error: name already bound\n}\n\nfunction type_class() {\n  type A = number;\n  class A {} // error: name already bound\n}\n\nfunction type_let() {\n  type A = number;\n  let A = 0; // error: name already bound\n}\n\nfunction type_const() {\n  type A = number;\n  const A = 0; // error: name already bound\n}\n\nfunction type_var() {\n  type A = number;\n  var A = 0; // error: name already bound\n}\n\nfunction type_reassign() {\n  type A = number;\n  A = 42; // error: type alias ref'd from value pos\n}\n\n// class x *\n\nfunction class_type() {\n  class A {}\n  type A = number; // error: name already bound\n}\n\nfunction class_class() {\n  class A {}\n  class A {} // error: name already bound\n}\n\nfunction class_let() {\n  class A {}\n  let A = 0; // error: name already bound\n}\n\nfunction class_const() {\n  class A {}\n  const A = 0; // error: name already bound\n}\n\nfunction class_var() {\n  class A {}\n  var A = 0; // error: name already bound\n}\n\n// let x *\n\nfunction let_type() {\n  let A = 0;\n  type A = number; // error: name already bound\n}\n\nfunction let_class() {\n  let A = 0;\n  class A {} // error: name already bound\n}\n\nfunction let_let() {\n  let A = 0;\n  let A = 0; // error: name already bound\n}\n\nfunction let_const() {\n  let A = 0;\n  const A = 0; // error: name already bound\n}\n\nfunction let_var() {\n  let A = 0;\n  var A = 0; // error: name already bound\n}\n\n// const x *\n\nfunction const_type() {\n  const A = 0;\n  type A = number; // error: name already bound\n}\n\nfunction const_class() {\n  const A = 0;\n  class A {} // error: name already bound\n}\n\nfunction const_let() {\n  const A = 0;\n  let A = 0; // error: name already bound\n}\n\nfunction const_const() {\n  const A = 0;\n  const A = 0; // error: name already bound\n}\n\nfunction const_var() {\n  const A = 0;\n  var A = 0; // error: name already bound\n}\n\nfunction const_reassign() {\n  const A = 0;\n  A = 42; // error: cannot be reassigned\n}\n\n// var x *\n\nfunction var_type() {\n  var A = 0;\n  type A = number; // error: name already bound\n}\n\nfunction var_class() {\n  var A = 0;\n  class A {} // error: name already bound\n}\n\nfunction var_let() {\n  var A = 0;\n  let A = 0; // error: name already bound\n}\n\nfunction var_const() {\n  var A = 0;\n  const A = 0; // error: name already bound\n}\n\nfunction var_var() {\n  var A = 0;\n  var A = 0; // OK\n}\n\n// function x *\n\nfunction function_toplevel() {\n  function a() {}\n  function a() {} // OK\n}\n\nfunction function_block() {\n  {\n    function a() {}\n    function a() {} // error: name already bound\n  }\n}\n\n// corner cases\n\nfunction var_shadow_nested_scope() {\n  {\n    let x = 0;\n    {\n      var x = 0; // error: name already bound\n    }\n  }\n}\n\nfunction type_shadow_nested_scope() {\n  {\n    let x = 0;\n    {\n      type x = string; // error: name already bound\n    }\n  }\n}\n\n// fn params name clash\n\nfunction fn_params_name_clash(x, x /* error: x already bound */) {}\nfunction fn_params_clash_fn_binding(x, y) {\n  let x = 0; // error: x already bound\n  var y = 0; // OK\n}");
    Ok(())
}
#[test]
fn test_scope_js_format_1_6c2845dd() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("function block_scope() {\n  let a: number = 0;\n  var b: number = 0;\n  {\n    let a = \"\"; // ok: local to block\n    var b = \"\"; // error: string ~> number\n  }\n}\n\nfunction switch_scope(x: string) {\n  let a: number = 0;\n  var b: number = 0;\n  switch (x) {\n    case \"foo\":\n      let a = \"\"; // ok: local to switch\n      var b = \"\"; // error: string ~> number\n      break;\n    case \"bar\":\n      let a = \"\"; // error: a already bound in switch\n      break;\n  }\n}\n\n// a switch is a single lexical scope, so lets and non-disjoint\n// cases can mix in odd ways. our support for edge cases is not\n// yet perfect.\nfunction switch_scope2(x: number) {\n  switch (x) {\n    case 0:\n     a = \"\";     // error: assign before declaration\n     break;\n    case 1:\n     var b = a;  // error: use before declaration\n     break;\n    case 2:\n      let a = \"\";\n      break;\n    case 3:\n      a = \"\";     // error: skipped initializer\n      break;\n    case 4:\n      var c:string = a;  // error: skipped initializer\n      break;\n  }\n  a = \"\"; // error: a no longer in scope\n}\n\nfunction try_scope() {\n  let a: number = 0;\n  try {\n    let a = \"\"; // ok\n  } catch (e) {\n    let a = \"\"; // ok\n  } finally {\n    let a = \"\"; // ok\n  }\n}\n\nfunction for_scope_let() {\n  let a: number = 0;\n  for (let a = \"\" /* ok: local to init */;;) {}\n}\n\nfunction for_scope_var() {\n  var a: number = 0;\n  for (var a = \"\" /* error: string ~> number */;;) {}\n}\n\nfunction for_in_scope_let(o: Object) {\n  let a: number = 0;\n  for (let a /* ok: local to init */ in o) {}\n}\n\nfunction for_in_scope_var(o: Object) {\n  var a: number = 0;\n  for (var a /* error: string ~> number */ in o) {}\n}\n\nfunction for_of_scope_let(xs: string[]) {\n  let a: number = 0;\n  for (let a /* ok: local to init */ of xs) {}\n}\n\nfunction for_of_scope_var(xs: string[]) {\n  var a: number = 0;\n  for (var a /* error: string ~> number */ of xs) {}\n}\n\nfunction default_param_1() {\n  // function binding in scope in default expr\n  function f(\n    x: () => string = f // error: number ~> string\n  ): number {\n    return 0;\n  }\n}\n\nfunction default_param_2() {\n  // fn body bindings not visible from param scope\n  let a = \"\";\n  function f0(x = () => a): number {\n    let a = 0;\n    return x(); // error: string ~> number\n  }\n  function f1(x = b /* error: cannot resolve b */): number {\n    let b = 0;\n    return x;\n  }\n}") ? ;
    assert_eq ! (formatted , "function block_scope() {\n  let a: number = 0;\n  var b: number = 0;\n  {\n    let a = \"\"; // ok: local to block\n    var b = \"\"; // error: string ~> number\n  }\n}\n\nfunction switch_scope(x: string) {\n  let a: number = 0;\n  var b: number = 0;\n  switch (x) {\n    case \"foo\":\n      let a = \"\"; // ok: local to switch\n      var b = \"\"; // error: string ~> number\n      break;\n    case \"bar\":\n      let a = \"\"; // error: a already bound in switch\n      break;\n  }\n}\n\n// a switch is a single lexical scope, so lets and non-disjoint\n// cases can mix in odd ways. our support for edge cases is not\n// yet perfect.\nfunction switch_scope2(x: number) {\n  switch (x) {\n    case 0:\n      a = \"\"; // error: assign before declaration\n      break;\n    case 1:\n      var b = a; // error: use before declaration\n      break;\n    case 2:\n      let a = \"\";\n      break;\n    case 3:\n      a = \"\"; // error: skipped initializer\n      break;\n    case 4:\n      var c: string = a; // error: skipped initializer\n      break;\n  }\n  a = \"\"; // error: a no longer in scope\n}\n\nfunction try_scope() {\n  let a: number = 0;\n  try {\n    let a = \"\"; // ok\n  } catch (e) {\n    let a = \"\"; // ok\n  } finally {\n    let a = \"\"; // ok\n  }\n}\n\nfunction for_scope_let() {\n  let a: number = 0;\n  for (let a = \"\" /* ok: local to init */; ; ) {}\n}\n\nfunction for_scope_var() {\n  var a: number = 0;\n  for (var a = \"\" /* error: string ~> number */; ; ) {}\n}\n\nfunction for_in_scope_let(o: Object) {\n  let a: number = 0;\n  for (let a /* ok: local to init */ in o) {\n  }\n}\n\nfunction for_in_scope_var(o: Object) {\n  var a: number = 0;\n  for (var a /* error: string ~> number */ in o) {\n  }\n}\n\nfunction for_of_scope_let(xs: string[]) {\n  let a: number = 0;\n  for (let a /* ok: local to init */ of xs) {\n  }\n}\n\nfunction for_of_scope_var(xs: string[]) {\n  var a: number = 0;\n  for (var a /* error: string ~> number */ of xs) {\n  }\n}\n\nfunction default_param_1() {\n  // function binding in scope in default expr\n  function f(\n    x: () => string = f, // error: number ~> string\n  ): number {\n    return 0;\n  }\n}\n\nfunction default_param_2() {\n  // fn body bindings not visible from param scope\n  let a = \"\";\n  function f0(x = () => a): number {\n    let a = 0;\n    return x(); // error: string ~> number\n  }\n  function f1(x = b /* error: cannot resolve b */): number {\n    let b = 0;\n    return x;\n  }\n}");
    Ok(())
}
#[test]
fn test_tdz_js_format_1_ff309121() -> Result<()> {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/** @flow */\n\n// -- types ---\n\n// type aliases are hoisted and always available\n\ntype T1 = T2;   // ok\ntype T2 = number;\n\n// --- lets ---\n\n// to be correct, we would\n// - not allow forward refs to lets from value positions,\n// while let is in TDZ.\n// - allow forward refs to lets from type positions.\n//\n// currently we're too lenient about TDZ in closures -\n// from value positions, we currently enforce TDZ only in-scope.\n// this is unsound - a let or const may remain uninitialized when\n// a lambda runs. But a simple conservative approach would prohibit\n// forward references to let/consts from within lambdas entirely,\n// which would be annoying. TODO\n\nfunction f0() {\n  var v = x * c;  // errors, let + const referenced before decl\n  let x = 0;\n  const c = 0;\n}\n\nfunction f1(b) {\n  x = 10;         // error, attempt to write to let before decl\n  let x = 0;\n  if (b) {\n    y = 10;       // error, attempt to write to let before decl\n    let y = 0;\n  }\n}\n\nfunction f2() {\n  {\n    var v = x * c; // errors, let + const referenced before decl\n  }\n  let x = 0;\n  const c = 0;\n}\n\n// functions are let-scoped and hoisted\nfunction f3() {\n  var s: string = foo();          // ok, finds hoisted outer\n  {\n    var n: number = foo();        // ok, finds hoisted inner\n    function foo() { return 0; }\n  }\n  var s2: string = foo();         // ok, hoisted outer not clobbered\n  function foo() { return \"\"; }\n}\n\n// out-of-scope TDZ not enforced. sometimes right...\nfunction f4() {\n  function g() { return x + c; }  // ok, g doesn't run in TDZ\n  let x = 0;\n  const c = 0;\n}\n\n// ...sometimes wrong\nfunction f5() {\n  function g() { return x; }\n  g();          // should error, but doesn't currently\n  let x = 0;\n  const c = 0;\n}\n\n// - from type positions, we currently error on forward refs to any\n// value (i.e., class or function). this is a basic flaw in our\n// phasing of AST traversal, and will be fixed.\n//\n\nvar x: C;       // ok\n\nvar y = new C(); // error: let ref before decl from value position\n\nclass C {}\n\nvar z: C = new C(); // ok\n\n// --- vars ---\n\n// it's possible to annotate a var with a non-maybe type,\n// but leave it uninitialized until later (as long as it's\n// initialized before use)\n\nvar a: number;  // not an error per se - only if used before init\n\nfunction f(n: number) { return n; }\n\nf(a); // error: undefined ~/> number\n\na = 10;\n\nf(a); // ok, a: number (not ?number)") ? ;
    assert_eq ! (formatted , "/** @flow */\n\n// -- types ---\n\n// type aliases are hoisted and always available\n\ntype T1 = T2; // ok\ntype T2 = number;\n\n// --- lets ---\n\n// to be correct, we would\n// - not allow forward refs to lets from value positions,\n// while let is in TDZ.\n// - allow forward refs to lets from type positions.\n//\n// currently we're too lenient about TDZ in closures -\n// from value positions, we currently enforce TDZ only in-scope.\n// this is unsound - a let or const may remain uninitialized when\n// a lambda runs. But a simple conservative approach would prohibit\n// forward references to let/consts from within lambdas entirely,\n// which would be annoying. TODO\n\nfunction f0() {\n  var v = x * c; // errors, let + const referenced before decl\n  let x = 0;\n  const c = 0;\n}\n\nfunction f1(b) {\n  x = 10; // error, attempt to write to let before decl\n  let x = 0;\n  if (b) {\n    y = 10; // error, attempt to write to let before decl\n    let y = 0;\n  }\n}\n\nfunction f2() {\n  {\n    var v = x * c; // errors, let + const referenced before decl\n  }\n  let x = 0;\n  const c = 0;\n}\n\n// functions are let-scoped and hoisted\nfunction f3() {\n  var s: string = foo(); // ok, finds hoisted outer\n  {\n    var n: number = foo(); // ok, finds hoisted inner\n    function foo() {\n      return 0;\n    }\n  }\n  var s2: string = foo(); // ok, hoisted outer not clobbered\n  function foo() {\n    return \"\";\n  }\n}\n\n// out-of-scope TDZ not enforced. sometimes right...\nfunction f4() {\n  function g() {\n    return x + c;\n  } // ok, g doesn't run in TDZ\n  let x = 0;\n  const c = 0;\n}\n\n// ...sometimes wrong\nfunction f5() {\n  function g() {\n    return x;\n  }\n  g(); // should error, but doesn't currently\n  let x = 0;\n  const c = 0;\n}\n\n// - from type positions, we currently error on forward refs to any\n// value (i.e., class or function). this is a basic flaw in our\n// phasing of AST traversal, and will be fixed.\n//\n\nvar x: C; // ok\n\nvar y = new C(); // error: let ref before decl from value position\n\nclass C {}\n\nvar z: C = new C(); // ok\n\n// --- vars ---\n\n// it's possible to annotate a var with a non-maybe type,\n// but leave it uninitialized until later (as long as it's\n// initialized before use)\n\nvar a: number; // not an error per se - only if used before init\n\nfunction f(n: number) {\n  return n;\n}\n\nf(a); // error: undefined ~/> number\n\na = 10;\n\nf(a); // ok, a: number (not ?number)");
    Ok(())
}
