#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[allow(dead_code)]
static INFINITY: usize = usize::MAX;
#[test]
fn test_ast_js_format_1_32b420a4() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/**\n * @flow\n */\n\nexport type InferredType =\n  | 'unknown'\n  | 'gender'\n  | 'enum'\n  | 'number-or-string'\n  | 'number'\n  | 'string'\n  | 'error'\n;\n\nexport type Pos = {\n  firstLine: number,\n  firstColumn: number,\n  lastLine: number,\n  lastColumn: number,\n};\n\nexport type TypedBinaryOpNode = {\n  exprNodeType: 'binary_op',\n  binaryOp: 'plus' | 'multiply' | 'divide' | 'minus',\n  lhs: TypedNode,\n  rhs: TypedNode,\n  pos: Pos,\n  exprType: InferredType,\n  typed: true,\n}\n\nexport type TypedUnaryMinusNode = {\n  exprNodeType: 'unary_minus',\n  op: TypedNode,\n  pos: Pos,\n  exprType: InferredType,\n  typed: true,\n}\n\nexport type TypedNumberNode = {\n  exprNodeType: 'number',\n  value: number,\n  pos: Pos,\n  exprType: 'number',\n  typed: true,\n}\n\nexport type TypedStringLiteralNode = {\n  exprNodeType: 'string_literal',\n  value: string,\n  pos: Pos,\n  exprType: 'string',\n  typed: true,\n}\n\nexport type TypedVariableNode = {\n  exprNodeType: 'variable',\n  name: string,\n  pos: Pos,\n  exprType: InferredType,\n  typed: true,\n};\n\nexport type TypedFunctionInvocationNode = {\n  exprNodeType: 'function_invocation',\n  name: string,\n  parameters: TypedNode[],\n  pos: Pos,\n  exprType: 'error' | 'string',\n  typed: true,\n}\n\nexport type TypedNode =\n  | TypedBinaryOpNode\n  | TypedUnaryMinusNode\n  | TypedNumberNode\n  | TypedStringLiteralNode\n  | TypedVariableNode\n  | TypedFunctionInvocationNode\n;") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/**\n * @flow\n */\n\nexport type InferredType =\n  | \"unknown\"\n  | \"gender\"\n  | \"enum\"\n  | \"number-or-string\"\n  | \"number\"\n  | \"string\"\n  | \"error\";\n\nexport type Pos = {\n  firstLine: number,\n  firstColumn: number,\n  lastLine: number,\n  lastColumn: number,\n};\n\nexport type TypedBinaryOpNode = {\n  exprNodeType: \"binary_op\",\n  binaryOp: \"plus\" | \"multiply\" | \"divide\" | \"minus\",\n  lhs: TypedNode,\n  rhs: TypedNode,\n  pos: Pos,\n  exprType: InferredType,\n  typed: true,\n};\n\nexport type TypedUnaryMinusNode = {\n  exprNodeType: \"unary_minus\",\n  op: TypedNode,\n  pos: Pos,\n  exprType: InferredType,\n  typed: true,\n};\n\nexport type TypedNumberNode = {\n  exprNodeType: \"number\",\n  value: number,\n  pos: Pos,\n  exprType: \"number\",\n  typed: true,\n};\n\nexport type TypedStringLiteralNode = {\n  exprNodeType: \"string_literal\",\n  value: string,\n  pos: Pos,\n  exprType: \"string\",\n  typed: true,\n};\n\nexport type TypedVariableNode = {\n  exprNodeType: \"variable\",\n  name: string,\n  pos: Pos,\n  exprType: InferredType,\n  typed: true,\n};\n\nexport type TypedFunctionInvocationNode = {\n  exprNodeType: \"function_invocation\",\n  name: string,\n  parameters: TypedNode[],\n  pos: Pos,\n  exprType: \"error\" | \"string\",\n  typed: true,\n};\n\nexport type TypedNode =\n  | TypedBinaryOpNode\n  | TypedUnaryMinusNode\n  | TypedNumberNode\n  | TypedStringLiteralNode\n  | TypedVariableNode\n  | TypedFunctionInvocationNode;");
}
#[test]
fn test_emit_js_format_1_faa56e80() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/**\n * @flow\n */\nimport * as t from './jsAst';\n\nconst b = t.builders;\n\nimport type {\n        TypedNode\n} from './ast';\n\nfunction getBinaryOp(op: 'plus' | 'minus' | 'divide' | 'multiply') : '+' | '-' | '*' | '/' {\n  switch (op) {\n  case 'plus':\n    return '+';\n  case 'minus':\n    return '-';\n  case 'divide':\n    return '/';\n  case 'multiply':\n    return '*';\n  default:\n    throw new Error('Invalid binary operator: ' + op);\n  }\n}\n\nexport function emitExpression(node: TypedNode) : t.Expression {\n  switch (node.exprNodeType) {\n  case 'string_literal': // FALLTHROUGH\n  case 'number':\n    return b.literal(node.value);\n  case 'variable':\n    return b.memberExpression(\n      b.identifier('vars'),\n      b.identifier(node.name),\n      false\n    );\n  case 'binary_op': {\n    const lhs = emitExpression(node.lhs);\n    const rhs = emitExpression(node.rhs);\n\n    const op = getBinaryOp(node.binaryOp);\n    return b.binaryExpression(op, lhs, rhs);\n  }\n  case 'unary_minus': {\n    const operand = emitExpression(node.op);\n    return b.unaryExpression('-', operand, true);\n  }\n  case 'function_invocation': {\n    const callee = b.memberExpression(\n      b.identifier('fns'),\n      b.identifier(node.name),\n      false\n    );\n\n    const args = node.parameters.map(\n      (n) => emitExpression(n)\n    );\n\n    return b.callExpression(callee, args);\n  }\n  default:\n    throw new Error('Unknown expression type: ' + node.type);\n  }\n}") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/**\n * @flow\n */\nimport * as t from \"./jsAst\";\n\nconst b = t.builders;\n\nimport type { TypedNode } from \"./ast\";\n\nfunction getBinaryOp(\n  op: \"plus\" | \"minus\" | \"divide\" | \"multiply\",\n): \"+\" | \"-\" | \"*\" | \"/\" {\n  switch (op) {\n    case \"plus\":\n      return \"+\";\n    case \"minus\":\n      return \"-\";\n    case \"divide\":\n      return \"/\";\n    case \"multiply\":\n      return \"*\";\n    default:\n      throw new Error(\"Invalid binary operator: \" + op);\n  }\n}\n\nexport function emitExpression(node: TypedNode): t.Expression {\n  switch (node.exprNodeType) {\n    case \"string_literal\": // FALLTHROUGH\n    case \"number\":\n      return b.literal(node.value);\n    case \"variable\":\n      return b.memberExpression(\n        b.identifier(\"vars\"),\n        b.identifier(node.name),\n        false,\n      );\n    case \"binary_op\": {\n      const lhs = emitExpression(node.lhs);\n      const rhs = emitExpression(node.rhs);\n\n      const op = getBinaryOp(node.binaryOp);\n      return b.binaryExpression(op, lhs, rhs);\n    }\n    case \"unary_minus\": {\n      const operand = emitExpression(node.op);\n      return b.unaryExpression(\"-\", operand, true);\n    }\n    case \"function_invocation\": {\n      const callee = b.memberExpression(\n        b.identifier(\"fns\"),\n        b.identifier(node.name),\n        false,\n      );\n\n      const args = node.parameters.map((n) => emitExpression(n));\n\n      return b.callExpression(callee, args);\n    }\n    default:\n      throw new Error(\"Unknown expression type: \" + node.type);\n  }\n}");
}
#[test]
fn test_js_ast_js_format_1_2c5fbeeb() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/**\n * @flow\n */\nexport type Comment = {\n  loc: ?SourceLocation,\n  value: string,\n  leading: boolean,\n  trailing: boolean,\n};\n\nexport type SourceLocation = {\n  start: SourcePosition,\n  end: SourcePosition,\n  source: ?string,\n};\n\nexport type SourcePosition = {\n  line: number,\n  column: number,\n};\n\nexport type File = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'File',\n  program: Program,\n}\n\nexport type Program = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'Program',\n  body: Statement[],\n}\n\nexport type BinaryOperator =\n  |'=='\n  | '!='\n  | '==='\n  | '!=='\n  | '<'\n  | '<='\n  | '>'\n  | '>='\n  | '<<'\n  | '>>'\n  | '>>>'\n  | '+'\n  | '-'\n  | '*'\n  | '/'\n  | '%'\n  | '&' // TODO Missing from the Parser API.\n  | '|'\n  | '^'\n  | 'in'\n  | 'instanceof'\n  | '..'\n;\n\nexport type UnaryOperator =\n  | '-'\n  | '+'\n  | '!'\n  | '~'\n  | 'typeof'\n  | 'void'\n  | 'delete'\n;\n\nexport type AssignmentOperator =\n  | '='\n  | '+='\n  | '-='\n  | '*='\n  | '/='\n  | '%='\n  | '<<='\n  | '>>='\n  | '>>>='\n  | '|='\n  | '^='\n  | '&='\n;\n\nexport type UpdateOperator =\n  | '++'\n  | '--'\n;\n\nexport type LogicalOperator =\n  | '&&'\n  | '||'\n;\n\nexport type Node =\n  | EmptyStatement\n  | BlockStatement\n  | ExpressionStatement\n  | IfStatement\n  | BreakStatement\n  | ContinueStatement\n  | ReturnStatement\n  | ThrowStatement\n  | WhileStatement\n  | ForStatement\n  | ForInStatement\n  | TryStatement\n  | CatchClause\n  | Identifier\n  | Literal\n  | ThisExpression\n  | ArrayExpression\n  | ObjectExpreession\n  | Property\n  | FunctionExpression\n  | BinaryExpression\n  | UnaryExpression\n  | AssignmentExpression\n  | UpdateExpression\n  | LogicalExpression\n  | ConditionalExpression\n  | NewExpression\n  | CallExpression\n  | MemberExpression\n  | VariableDeclaration\n  | FunctionDeclaration\n  | VariableDeclarator\n;\n\nexport type Statement =\n  | BlockStatement\n  | EmptyStatement\n  | ExpressionStatement\n  | IfStatement\n  | BreakStatement\n  | ContinueStatement\n  | ReturnStatement\n  | ThrowStatement\n  | WhileStatement\n  | ForStatement\n  | ForInStatement\n  | TryStatement\n  | Declaration\n;\n\nexport type EmptyStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'EmptyStatement',\n}\n\nexport type BlockStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'BlockStatement',\n  body: Statement[],\n}\n\nexport type ExpressionStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'ExpressionStatement',\n  expression: Expression,\n}\n\nexport type IfStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'IfStatement',\n  test: Expression,\n  consequent: Statement,\n  alternate: ?Statement,\n}\n\nexport type BreakStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'BreakStatement',\n  label: ?Identifier,\n}\n\nexport type ContinueStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'ContinueStatement',\n  label: ?Identifier,\n}\n\nexport type ReturnStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'ReturnStatement',\n  argument: ?Expression,\n}\n\nexport type ThrowStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'ThrowStatement',\n  argument: ?Expression,\n}\n\nexport type WhileStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'WhileStatement',\n  test: Expression,\n  body: Statement,\n}\n\nexport type ForStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'ForStatement',\n  init: ?(VariableDeclaration | Expression),\n  test: ?Expression,\n  update: ?Expression,\n  body: Statement,\n}\n\nexport type ForInStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'ForInStatement',\n  left: VariableDeclaration | Expression,\n  right: Expression,\n  body: Statement,\n}\n\nexport type TryStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'TryStatement',\n  block: BlockStatement,\n  handler: ?CatchClause,\n  handlers: CatchClause[],\n  finalizer: ?BlockStatement,\n};\n\nexport type CatchClause = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'CatchClause',\n  param: Pattern,\n  guard: ?Expression,\n  body: BlockStatement,\n};\n\nexport type Expression =\n  | Identifier\n  | ThisExpression\n  | Literal\n  | FunctionExpression\n  | BinaryExpression\n  | UnaryExpression\n  | AssignmentExpression\n  | UpdateExpression\n  | LogicalExpression\n  | ConditionalExpression\n  | NewExpression\n  | CallExpression\n  | MemberExpression\n  | ArrayExpression\n  | ObjectExpreession\n;\n\nexport type Identifier = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'Identifier',\n  name: string,\n}\n\nexport type Literal = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'Literal',\n  value: ?(string | boolean | number | RegExp),\n  regex: ?{ pattern: string, flags: string },\n}\n\nexport type ThisExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'ThisExpression',\n}\n\nexport type ArrayExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'ArrayExpression',\n  elements: Expression[],\n}\n\nexport type ObjectExpreession = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'ObjectExpression',\n  properties: Property[],\n}\n\nexport type Property = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'Property',\n  kind: 'init' | 'get' | 'set',\n  key: Literal | Identifier,\n  value: Expression,\n};\n\nexport type FunctionExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'FunctionExpression',\n  id: ?Identifier,\n  params: Pattern[],\n  body: BlockStatement,\n}\n\nexport type BinaryExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'BinaryExpression',\n  operator: BinaryOperator,\n  left: Expression,\n  right: Expression,\n}\n\nexport type UnaryExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'UnaryExpression',\n  operator: UnaryOperator,\n  argument: Expression,\n  prefix: boolean,\n};\n\nexport type AssignmentExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'AssignmentExpression',\n  operator: AssignmentOperator,\n  left: Pattern,\n  right: Expression,\n};\n\nexport type UpdateExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'UpdateExpression',\n  operator: UpdateOperator,\n  argument: Expression,\n  prefix: boolean,\n};\n\nexport type LogicalExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'LogicalExpression',\n  operator: LogicalOperator,\n  left: Expression,\n  right: Expression,\n};\n\nexport type ConditionalExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'ConditionalExpression',\n  test: Expression,\n  consequent: Expression,\n  alternate: Expression,\n};\n\nexport type NewExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'NewExpression',\n  callee: Expression,\n  arguments: Expression[],\n};\n\nexport type CallExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'CallExpression',\n  callee: Expression,\n  arguments: Expression[],\n};\n\nexport type MemberExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'MemberExpression',\n  object: Expression,\n  property: Identifier | Expression,\n  computed: bool,\n}\n// ast-types exports all expressions as patterns.\n// That seems not like it was intended.\nexport type Pattern =\n  | Identifier\n;\n\nexport type Declaration =\n  | VariableDeclaration\n  | FunctionDeclaration\n;\n\nexport type VariableDeclaration = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'VariableDeclaration',\n  kind: 'var' | 'let' | 'const',\n  declarations: VariableDeclarator[],\n}\n\nexport type FunctionDeclaration = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'FunctionDeclaration',\n  id: Identifier,\n  body: BlockStatement,\n  params: Pattern[],\n}\n\nexport type VariableDeclarator = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: 'VariableDeclarator',\n  id: Pattern,\n  init: ?Expression,\n}\n\nconst a : any = null;\n\nexport const builders : {\n  emptyStatement() : EmptyStatement,\n  blockStatement(\n    body: Statement[]\n  ) : BlockStatement,\n  expressionStatement(\n    expression: Expression\n  ) : ExpressionStatement,\n  ifStatement(\n    test: Expression,\n    consequent: Statement,\n    alternate?: Statement\n  ) : IfStatement,\n  breakStatement(\n    label?: Identifier\n  ) : BreakStatement,\n  continueStatement(\n    label?: Identifier\n  ) : ContinueStatement,\n  returnStatement(\n    argument: ?Expression\n  ) : ReturnStatement,\n  throwStatement(\n    argument: ?Expression\n  ) : ThrowStatement,\n  whileStatement(\n    test: Expression,\n    body: Statement\n  ) : WhileStatement,\n  forStatement(\n    init: ?(VariableDeclaration | Expression),\n    test: ?Expression,\n    update: ?Expression,\n    body: Statement\n  ) : ForStatement,\n  forInStatement(\n    left: VariableDeclaration | Expression,\n    right: Expression,\n    body: Statement\n  ) : ForInStatement,\n  tryStatement(\n    block: BlockStatement,\n    handler: ?CatchClause,\n    handlers: CatchClause[],\n    finalizer?: BlockStatement\n  ) : TryStatement,\n  catchClause(\n    param: Pattern,\n    guard: ?Expression,\n    body: BlockStatement\n  ) : CatchClause,\n  identifier(\n    name: string\n  ) : Identifier,\n  literal(\n    value: ?(string | boolean | number | RegExp),\n    regex?: { pattern: string, flags: string }\n  ) : Literal,\n  thisExpression() : ThisExpression,\n  arrayExpression(\n    elements: Expression[]\n  ) : ArrayExpression,\n  objectExpreession(\n    properties: Property[]\n  ) : ObjectExpreession,\n  property(\n    kind: 'init' | 'get' | 'set',\n    key: Literal | Identifier,\n    value: Expression\n  ) : Property,\n  functionExpression(\n    id: ?Identifier,\n    params: Pattern[],\n    body: BlockStatement\n  ) : FunctionExpression,\n  binaryExpression(\n    operator: BinaryOperator,\n    left: Expression,\n    right: Expression\n  ) : BinaryExpression,\n  unaryExpression(\n    operator: UnaryOperator,\n    argument: Expression,\n    prefix: boolean\n  ) : UnaryExpression,\n  assignmentExpression(\n    operator: AssignmentOperator,\n    left: Pattern,\n    right: Expression\n  ) : AssignmentExpression,\n  updateExpression(\n    operator: UpdateOperator,\n    argument: Expression,\n    prefix: boolean\n  ) : UpdateExpression,\n  logicalExpression(\n    operator: LogicalOperator,\n    left: Expression,\n    right: Expression\n  ) : LogicalExpression,\n  conditionalExpression(\n    test: Expression,\n    consequent: Expression,\n    alternate: Expression\n  ) : ConditionalExpression,\n  newExpression(\n    callee: Expression,\n    arguments: Expression[]\n  ) : NewExpression,\n  callExpression(\n    callee: Expression,\n    arguments: Expression[]\n  ) : CallExpression,\n  memberExpression(\n    object: Expression,\n    property: Identifier | Expression,\n    computed: bool\n  ) : MemberExpression,\n  variableDeclaration(\n    kind: 'var' | 'let' | 'const',\n    declarations: VariableDeclarator[]\n  ) : VariableDeclaration,\n  functionDeclaration(\n    id: Identifier,\n    body: BlockStatement,\n    params: Pattern[]\n  ) : FunctionDeclaration,\n  variableDeclarator(\n    id: Pattern,\n    init?: Expression\n  ) : VariableDeclarator,\n} = a;") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/**\n * @flow\n */\nexport type Comment = {\n  loc: ?SourceLocation,\n  value: string,\n  leading: boolean,\n  trailing: boolean,\n};\n\nexport type SourceLocation = {\n  start: SourcePosition,\n  end: SourcePosition,\n  source: ?string,\n};\n\nexport type SourcePosition = {\n  line: number,\n  column: number,\n};\n\nexport type File = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"File\",\n  program: Program,\n};\n\nexport type Program = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"Program\",\n  body: Statement[],\n};\n\nexport type BinaryOperator =\n  | \"==\"\n  | \"!=\"\n  | \"===\"\n  | \"!==\"\n  | \"<\"\n  | \"<=\"\n  | \">\"\n  | \">=\"\n  | \"<<\"\n  | \">>\"\n  | \">>>\"\n  | \"+\"\n  | \"-\"\n  | \"*\"\n  | \"/\"\n  | \"%\"\n  | \"&\" // TODO Missing from the Parser API.\n  | \"|\"\n  | \"^\"\n  | \"in\"\n  | \"instanceof\"\n  | \"..\";\n\nexport type UnaryOperator =\n  | \"-\"\n  | \"+\"\n  | \"!\"\n  | \"~\"\n  | \"typeof\"\n  | \"void\"\n  | \"delete\";\n\nexport type AssignmentOperator =\n  | \"=\"\n  | \"+=\"\n  | \"-=\"\n  | \"*=\"\n  | \"/=\"\n  | \"%=\"\n  | \"<<=\"\n  | \">>=\"\n  | \">>>=\"\n  | \"|=\"\n  | \"^=\"\n  | \"&=\";\n\nexport type UpdateOperator = \"++\" | \"--\";\n\nexport type LogicalOperator = \"&&\" | \"||\";\n\nexport type Node =\n  | EmptyStatement\n  | BlockStatement\n  | ExpressionStatement\n  | IfStatement\n  | BreakStatement\n  | ContinueStatement\n  | ReturnStatement\n  | ThrowStatement\n  | WhileStatement\n  | ForStatement\n  | ForInStatement\n  | TryStatement\n  | CatchClause\n  | Identifier\n  | Literal\n  | ThisExpression\n  | ArrayExpression\n  | ObjectExpreession\n  | Property\n  | FunctionExpression\n  | BinaryExpression\n  | UnaryExpression\n  | AssignmentExpression\n  | UpdateExpression\n  | LogicalExpression\n  | ConditionalExpression\n  | NewExpression\n  | CallExpression\n  | MemberExpression\n  | VariableDeclaration\n  | FunctionDeclaration\n  | VariableDeclarator;\n\nexport type Statement =\n  | BlockStatement\n  | EmptyStatement\n  | ExpressionStatement\n  | IfStatement\n  | BreakStatement\n  | ContinueStatement\n  | ReturnStatement\n  | ThrowStatement\n  | WhileStatement\n  | ForStatement\n  | ForInStatement\n  | TryStatement\n  | Declaration;\n\nexport type EmptyStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"EmptyStatement\",\n};\n\nexport type BlockStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"BlockStatement\",\n  body: Statement[],\n};\n\nexport type ExpressionStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"ExpressionStatement\",\n  expression: Expression,\n};\n\nexport type IfStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"IfStatement\",\n  test: Expression,\n  consequent: Statement,\n  alternate: ?Statement,\n};\n\nexport type BreakStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"BreakStatement\",\n  label: ?Identifier,\n};\n\nexport type ContinueStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"ContinueStatement\",\n  label: ?Identifier,\n};\n\nexport type ReturnStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"ReturnStatement\",\n  argument: ?Expression,\n};\n\nexport type ThrowStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"ThrowStatement\",\n  argument: ?Expression,\n};\n\nexport type WhileStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"WhileStatement\",\n  test: Expression,\n  body: Statement,\n};\n\nexport type ForStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"ForStatement\",\n  init: ?(VariableDeclaration | Expression),\n  test: ?Expression,\n  update: ?Expression,\n  body: Statement,\n};\n\nexport type ForInStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"ForInStatement\",\n  left: VariableDeclaration | Expression,\n  right: Expression,\n  body: Statement,\n};\n\nexport type TryStatement = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"TryStatement\",\n  block: BlockStatement,\n  handler: ?CatchClause,\n  handlers: CatchClause[],\n  finalizer: ?BlockStatement,\n};\n\nexport type CatchClause = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"CatchClause\",\n  param: Pattern,\n  guard: ?Expression,\n  body: BlockStatement,\n};\n\nexport type Expression =\n  | Identifier\n  | ThisExpression\n  | Literal\n  | FunctionExpression\n  | BinaryExpression\n  | UnaryExpression\n  | AssignmentExpression\n  | UpdateExpression\n  | LogicalExpression\n  | ConditionalExpression\n  | NewExpression\n  | CallExpression\n  | MemberExpression\n  | ArrayExpression\n  | ObjectExpreession;\n\nexport type Identifier = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"Identifier\",\n  name: string,\n};\n\nexport type Literal = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"Literal\",\n  value: ?(string | boolean | number | RegExp),\n  regex: ?{ pattern: string, flags: string },\n};\n\nexport type ThisExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"ThisExpression\",\n};\n\nexport type ArrayExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"ArrayExpression\",\n  elements: Expression[],\n};\n\nexport type ObjectExpreession = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"ObjectExpression\",\n  properties: Property[],\n};\n\nexport type Property = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"Property\",\n  kind: \"init\" | \"get\" | \"set\",\n  key: Literal | Identifier,\n  value: Expression,\n};\n\nexport type FunctionExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"FunctionExpression\",\n  id: ?Identifier,\n  params: Pattern[],\n  body: BlockStatement,\n};\n\nexport type BinaryExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"BinaryExpression\",\n  operator: BinaryOperator,\n  left: Expression,\n  right: Expression,\n};\n\nexport type UnaryExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"UnaryExpression\",\n  operator: UnaryOperator,\n  argument: Expression,\n  prefix: boolean,\n};\n\nexport type AssignmentExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"AssignmentExpression\",\n  operator: AssignmentOperator,\n  left: Pattern,\n  right: Expression,\n};\n\nexport type UpdateExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"UpdateExpression\",\n  operator: UpdateOperator,\n  argument: Expression,\n  prefix: boolean,\n};\n\nexport type LogicalExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"LogicalExpression\",\n  operator: LogicalOperator,\n  left: Expression,\n  right: Expression,\n};\n\nexport type ConditionalExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"ConditionalExpression\",\n  test: Expression,\n  consequent: Expression,\n  alternate: Expression,\n};\n\nexport type NewExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"NewExpression\",\n  callee: Expression,\n  arguments: Expression[],\n};\n\nexport type CallExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"CallExpression\",\n  callee: Expression,\n  arguments: Expression[],\n};\n\nexport type MemberExpression = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"MemberExpression\",\n  object: Expression,\n  property: Identifier | Expression,\n  computed: boolean,\n};\n// ast-types exports all expressions as patterns.\n// That seems not like it was intended.\nexport type Pattern = Identifier;\n\nexport type Declaration = VariableDeclaration | FunctionDeclaration;\n\nexport type VariableDeclaration = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"VariableDeclaration\",\n  kind: \"var\" | \"let\" | \"const\",\n  declarations: VariableDeclarator[],\n};\n\nexport type FunctionDeclaration = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"FunctionDeclaration\",\n  id: Identifier,\n  body: BlockStatement,\n  params: Pattern[],\n};\n\nexport type VariableDeclarator = {\n  source: ?string,\n  start: SourcePosition,\n  end: SourcePosition,\n  comments: ?Array<Comment>,\n  type: \"VariableDeclarator\",\n  id: Pattern,\n  init: ?Expression,\n};\n\nconst a: any = null;\n\nexport const builders: {\n  emptyStatement(): EmptyStatement,\n  blockStatement(body: Statement[]): BlockStatement,\n  expressionStatement(expression: Expression): ExpressionStatement,\n  ifStatement(\n    test: Expression,\n    consequent: Statement,\n    alternate?: Statement,\n  ): IfStatement,\n  breakStatement(label?: Identifier): BreakStatement,\n  continueStatement(label?: Identifier): ContinueStatement,\n  returnStatement(argument: ?Expression): ReturnStatement,\n  throwStatement(argument: ?Expression): ThrowStatement,\n  whileStatement(test: Expression, body: Statement): WhileStatement,\n  forStatement(\n    init: ?(VariableDeclaration | Expression),\n    test: ?Expression,\n    update: ?Expression,\n    body: Statement,\n  ): ForStatement,\n  forInStatement(\n    left: VariableDeclaration | Expression,\n    right: Expression,\n    body: Statement,\n  ): ForInStatement,\n  tryStatement(\n    block: BlockStatement,\n    handler: ?CatchClause,\n    handlers: CatchClause[],\n    finalizer?: BlockStatement,\n  ): TryStatement,\n  catchClause(\n    param: Pattern,\n    guard: ?Expression,\n    body: BlockStatement,\n  ): CatchClause,\n  identifier(name: string): Identifier,\n  literal(\n    value: ?(string | boolean | number | RegExp),\n    regex?: { pattern: string, flags: string },\n  ): Literal,\n  thisExpression(): ThisExpression,\n  arrayExpression(elements: Expression[]): ArrayExpression,\n  objectExpreession(properties: Property[]): ObjectExpreession,\n  property(\n    kind: \"init\" | \"get\" | \"set\",\n    key: Literal | Identifier,\n    value: Expression,\n  ): Property,\n  functionExpression(\n    id: ?Identifier,\n    params: Pattern[],\n    body: BlockStatement,\n  ): FunctionExpression,\n  binaryExpression(\n    operator: BinaryOperator,\n    left: Expression,\n    right: Expression,\n  ): BinaryExpression,\n  unaryExpression(\n    operator: UnaryOperator,\n    argument: Expression,\n    prefix: boolean,\n  ): UnaryExpression,\n  assignmentExpression(\n    operator: AssignmentOperator,\n    left: Pattern,\n    right: Expression,\n  ): AssignmentExpression,\n  updateExpression(\n    operator: UpdateOperator,\n    argument: Expression,\n    prefix: boolean,\n  ): UpdateExpression,\n  logicalExpression(\n    operator: LogicalOperator,\n    left: Expression,\n    right: Expression,\n  ): LogicalExpression,\n  conditionalExpression(\n    test: Expression,\n    consequent: Expression,\n    alternate: Expression,\n  ): ConditionalExpression,\n  newExpression(callee: Expression, arguments: Expression[]): NewExpression,\n  callExpression(callee: Expression, arguments: Expression[]): CallExpression,\n  memberExpression(\n    object: Expression,\n    property: Identifier | Expression,\n    computed: boolean,\n  ): MemberExpression,\n  variableDeclaration(\n    kind: \"var\" | \"let\" | \"const\",\n    declarations: VariableDeclarator[],\n  ): VariableDeclaration,\n  functionDeclaration(\n    id: Identifier,\n    body: BlockStatement,\n    params: Pattern[],\n  ): FunctionDeclaration,\n  variableDeclarator(id: Pattern, init?: Expression): VariableDeclarator,\n} = a;");
}
