#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[test]
fn test_test_js_format_1_a3306570() {
    let pretty_printer = PrettyPrinterBuilder::default().build().unwrap();
    let formatted = pretty_printer . format ("/**\n * Test nonstrict type param arity checking,\n * as enabled by\n *\n * [options]\n * experimental.strict_type_args=false\n *\n * in .flowconfig.\n *\n * @flow\n */\n\n// no arity error in type annotation using polymorphic class\n\nclass MyClass<T> {\n  x: T;\n  constructor(x: T) {\n    this.x = x;\n  }\n}\n\nvar c: MyClass = new MyClass(0); // no error\n\n// no arity error in type annotation using polymorphic class with defaulting\n\nclass MyClass2<T, U = string> {\n  x: T;\n  y: U;\n  constructor(x: T, y: U) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nvar c2: MyClass2 = new MyClass2(0, \"\"); // no error\n\n// no arity error in type annotation using polymorphic type alias\n\ntype MyObject<T> = {\n  x: T;\n}\n\nvar o: MyObject = { x: 0 }; // no error\n\n// arity error in type alias rhs\n\ntype MySubobject = { y: number } & MyObject; // no error\n\n// arity error in interface extends\n\ninterface MyInterface<T> {\n  x: T;\n}\n\ninterface MySubinterface extends MyInterface { // no error\n  y: number;\n}\n\n// no arity error in extends of polymorphic class\n\nclass MySubclass extends MyClass { // ok, type arg inferred\n  y: number;\n  constructor(y: number) {\n    super(y);\n  }\n}\n\n// no arity error in call of polymorphic function\n\nfunction singleton<T>(x: T):Array<T> { return [x]; }\n\nvar num_array:Array<number> = singleton(0); // ok, type arg inferred") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/**\n * Test nonstrict type param arity checking,\n * as enabled by\n *\n * [options]\n * experimental.strict_type_args=false\n *\n * in .flowconfig.\n *\n * @flow\n */\n\n// no arity error in type annotation using polymorphic class\n\nclass MyClass<T> {\n  x: T;\n  constructor(x: T) {\n    this.x = x;\n  }\n}\n\nvar c: MyClass = new MyClass(0); // no error\n\n// no arity error in type annotation using polymorphic class with defaulting\n\nclass MyClass2<T, U = string> {\n  x: T;\n  y: U;\n  constructor(x: T, y: U) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nvar c2: MyClass2 = new MyClass2(0, \"\"); // no error\n\n// no arity error in type annotation using polymorphic type alias\n\ntype MyObject<T> = {\n  x: T,\n};\n\nvar o: MyObject = { x: 0 }; // no error\n\n// arity error in type alias rhs\n\ntype MySubobject = { y: number } & MyObject; // no error\n\n// arity error in interface extends\n\ninterface MyInterface<T> {\n  x: T;\n}\n\ninterface MySubinterface extends MyInterface {\n  // no error\n  y: number;\n}\n\n// no arity error in extends of polymorphic class\n\nclass MySubclass extends MyClass {\n  // ok, type arg inferred\n  y: number;\n  constructor(y: number) {\n    super(y);\n  }\n}\n\n// no arity error in call of polymorphic function\n\nfunction singleton<T>(x: T): Array<T> {\n  return [x];\n}\n\nvar num_array: Array<number> = singleton(0); // ok, type arg inferred");
}
