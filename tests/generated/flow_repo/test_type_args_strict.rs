use pretty_assertions::assert_eq;
#[allow(unused_imports)]
use rust_prettier::PrettyPrinterBuilder;
#[allow(dead_code)]
static INFINITY: usize = usize::MAX;
#[test]
fn test_test_js_format_1_09ceea00() {
    let pretty_printer = PrettyPrinterBuilder::default()
        .parser("js")
        .print_width(80)
        .build()
        .unwrap();
    let formatted = pretty_printer . format ("/**\n * Test strict type param arity checking.\n *\n * Full type argument lists are required in type expressions,\n * such as type annotations and interface extends clauses.\n * Type arguments are optional in value expressions, such as\n * class extends clauses and calls of polymorphic functions.\n *\n * @flow\n */\n\n// arity error in type annotation using polymorphic class\n\nclass MyClass<T> {\n  x: T;\n  constructor(x: T) {\n    this.x = x;\n  }\n}\n\nvar c: MyClass = new MyClass(0); // error, missing argument list (1)\n\n// arity error in type annotation using polymorphic class with defaulting\n\nclass MyClass2<T, U = string> {\n  x: T;\n  y: U;\n  constructor(x: T, y: U) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nvar c2: MyClass2 = new MyClass2(0, \"\"); // error, missing argument list (1-2)\n\n// arity error in type annotation using polymorphic type alias\n\ntype MyObject<T> = {\n  x: T;\n}\n\nvar o: MyObject = { x: 0 }; // error, missing argument list\n\n// arity error in type alias rhs\n\ntype MySubobject = { y: number } & MyObject; // error, missing argument list\n\n// arity error in interface extends\n\ninterface MyInterface<T> {\n  x: T;\n}\n\ninterface MySubinterface extends MyInterface { // error, missing argument list\n  y: number;\n}\n\n// *no* arity error in extends of polymorphic class\n\nclass MySubclass extends MyClass { // ok, type arg inferred\n  y: number;\n  constructor(y: number) {\n    super(y);\n  }\n}\n\n// *no* arity error in call of polymorphic function\n\nfunction singleton<T>(x: T):Array<T> { return [x]; }\n\nvar num_array:Array<number> = singleton(0); // ok, type arg inferred") ;
    assert!(formatted.is_ok());
    let formatted = formatted.unwrap();
    assert_eq ! (formatted , "/**\n * Test strict type param arity checking.\n *\n * Full type argument lists are required in type expressions,\n * such as type annotations and interface extends clauses.\n * Type arguments are optional in value expressions, such as\n * class extends clauses and calls of polymorphic functions.\n *\n * @flow\n */\n\n// arity error in type annotation using polymorphic class\n\nclass MyClass<T> {\n  x: T;\n  constructor(x: T) {\n    this.x = x;\n  }\n}\n\nvar c: MyClass = new MyClass(0); // error, missing argument list (1)\n\n// arity error in type annotation using polymorphic class with defaulting\n\nclass MyClass2<T, U = string> {\n  x: T;\n  y: U;\n  constructor(x: T, y: U) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nvar c2: MyClass2 = new MyClass2(0, \"\"); // error, missing argument list (1-2)\n\n// arity error in type annotation using polymorphic type alias\n\ntype MyObject<T> = {\n  x: T,\n};\n\nvar o: MyObject = { x: 0 }; // error, missing argument list\n\n// arity error in type alias rhs\n\ntype MySubobject = { y: number } & MyObject; // error, missing argument list\n\n// arity error in interface extends\n\ninterface MyInterface<T> {\n  x: T;\n}\n\ninterface MySubinterface extends MyInterface {\n  // error, missing argument list\n  y: number;\n}\n\n// *no* arity error in extends of polymorphic class\n\nclass MySubclass extends MyClass {\n  // ok, type arg inferred\n  y: number;\n  constructor(y: number) {\n    super(y);\n  }\n}\n\n// *no* arity error in call of polymorphic function\n\nfunction singleton<T>(x: T): Array<T> {\n  return [x];\n}\n\nvar num_array: Array<number> = singleton(0); // ok, type arg inferred");
}
